<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AgentFlow v2a â€” Radial Orbit | AgentPane</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500;600&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* ========================================
       Reset & Foundation
       ======================================== */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
    ul, ol { list-style: none; }
    button { cursor: pointer; border: none; background: none; font: inherit; color: inherit; }
    input { font: inherit; color: inherit; }

    :root {
      --bg-canvas: #0d1117;
      --bg-default: #161b22;
      --bg-subtle: #1c2128;
      --bg-muted: #21262d;
      --bg-emphasis: #30363d;
      --fg-default: #e6edf3;
      --fg-muted: #8b949e;
      --fg-subtle: #6e7681;
      --fg-on-emphasis: #ffffff;
      --border-default: #30363d;
      --border-muted: #21262d;
      --accent-fg: #58a6ff;
      --accent-emphasis: #1f6feb;
      --accent-muted: rgba(56, 139, 253, 0.15);
      --success-fg: #3fb950;
      --danger-fg: #f85149;
      --attention-fg: #d29922;
      --done-fg: #a371f7;
      --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
      --font-mono: 'Fira Code', 'SF Mono', Menlo, Consolas, monospace;
      --radius-sm: 4px;
      --radius: 6px;
      --radius-lg: 12px;
      --radius-full: 9999px;
      --duration-fast: 150ms;
      --duration-normal: 200ms;
      --duration-slow: 300ms;
      --easing: cubic-bezier(0.25, 1, 0.5, 1);

      /* Agent type colors */
      --color-orchestrator: #FFD866;
      --color-planner: #A78BFA;
      --color-coder: #67E8F9;
      --color-reviewer: #C084FC;
      --color-tester: #FCA572;
      --color-scanner: #F87171;
      --color-deployer: #34D399;

      /* Status colors */
      --status-completed: #A78BFA;
      --status-running: #34D399;
      --status-verifying: #FFD866;
      --status-blocked: #FCA572;
      --status-failed: #F87171;
      --status-queued: #475569;
    }

    body {
      font-family: var(--font-sans);
      font-size: 13px;
      color: var(--fg-default);
      background: var(--bg-canvas);
      height: 100vh;
      overflow: hidden;
    }

    /* Subtle grid background */
    body::after {
      content: '';
      position: fixed;
      inset: 0;
      background-image:
        linear-gradient(rgba(88, 166, 255, 0.012) 1px, transparent 1px),
        linear-gradient(90deg, rgba(88, 166, 255, 0.012) 1px, transparent 1px);
      background-size: 32px 32px;
      pointer-events: none;
      z-index: 0;
    }

    /* Atmospheric glow */
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background:
        radial-gradient(ellipse 900px 500px at 30% 30%, rgba(88, 166, 255, 0.03), transparent),
        radial-gradient(ellipse 700px 400px at 70% 70%, rgba(52, 211, 153, 0.02), transparent);
      pointer-events: none;
      z-index: 0;
    }

    /* ========================================
       Layout
       ======================================== */
    .page {
      display: flex;
      flex-direction: column;
      height: 100vh;
      position: relative;
      z-index: 1;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 20px;
      border-bottom: 1px solid var(--border-default);
      background: rgba(13, 17, 23, 0.9);
      backdrop-filter: blur(12px);
      flex-shrink: 0;
      z-index: 50;
      gap: 16px;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      font-weight: 600;
      color: var(--fg-default);
      letter-spacing: -0.02em;
    }

    .logo-icon {
      width: 24px;
      height: 24px;
      background: linear-gradient(135deg, var(--accent-fg), var(--done-fg));
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: white;
      font-weight: 700;
    }

    .logo-badge {
      font-size: 10px;
      padding: 2px 6px;
      background: var(--accent-muted);
      color: var(--accent-fg);
      border-radius: var(--radius-full);
      font-weight: 500;
    }

    .header-center {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .sim-controls {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      background: var(--bg-default);
      border: 1px solid var(--border-default);
      border-radius: var(--radius);
    }

    .sim-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      border-radius: var(--radius-sm);
      transition: all var(--duration-fast) var(--easing);
      font-size: 14px;
    }

    .sim-btn:hover { background: var(--bg-subtle); }
    .sim-btn.active { background: var(--accent-muted); color: var(--accent-fg); }

    .speed-indicator {
      font-size: 11px;
      font-family: var(--font-mono);
      color: var(--fg-subtle);
      padding: 0 4px;
      min-width: 28px;
      text-align: center;
    }

    .speed-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2px 8px;
      border-radius: var(--radius-sm);
      font-size: 11px;
      font-family: var(--font-mono);
      color: var(--fg-subtle);
      transition: all var(--duration-fast) var(--easing);
    }
    .speed-btn:hover { background: var(--bg-subtle); color: var(--fg-default); }
    .speed-btn.active { background: var(--accent-muted); color: var(--accent-fg); }

    .metric-pill {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      background: var(--bg-default);
      border: 1px solid var(--border-default);
      border-radius: var(--radius-full);
      font-size: 11px;
      font-family: var(--font-mono);
    }

    .metric-pill .label { color: var(--fg-subtle); }
    .metric-pill .value { color: var(--fg-default); font-weight: 500; }
    .metric-pill .value.running { color: var(--status-running); }
    .metric-pill .value.cost { color: var(--color-orchestrator); }

    /* Main content split */
    .main-content {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* ========================================
       Canvas Area
       ======================================== */
    .canvas-area {
      flex: 1;
      position: relative;
      overflow: hidden;
      min-width: 0;
    }

    .canvas-toolbar {
      position: absolute;
      top: 12px;
      left: 12px;
      display: flex;
      gap: 4px;
      z-index: 20;
      background: rgba(22, 27, 34, 0.9);
      backdrop-filter: blur(8px);
      border: 1px solid var(--border-default);
      border-radius: var(--radius);
      padding: 4px;
    }

    .canvas-toolbar button {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      border-radius: var(--radius-sm);
      font-size: 13px;
      color: var(--fg-muted);
      transition: all var(--duration-fast) var(--easing);
    }

    .canvas-toolbar button:hover { background: var(--bg-subtle); color: var(--fg-default); }
    .canvas-toolbar button.active { background: var(--accent-muted); color: var(--accent-fg); }

    .canvas-toolbar .separator {
      width: 1px;
      background: var(--border-default);
      margin: 2px 2px;
    }

    .zoom-indicator {
      position: absolute;
      bottom: 12px;
      left: 12px;
      z-index: 20;
      font-size: 11px;
      font-family: var(--font-mono);
      color: var(--fg-subtle);
      background: rgba(22, 27, 34, 0.9);
      backdrop-filter: blur(8px);
      border: 1px solid var(--border-default);
      border-radius: var(--radius);
      padding: 4px 8px;
    }

    .task-filter-bar {
      position: absolute;
      top: 12px;
      right: 12px;
      display: flex;
      gap: 4px;
      z-index: 20;
      flex-wrap: wrap;
      max-width: 50%;
      justify-content: flex-end;
    }

    .task-filter-chip {
      padding: 4px 10px;
      font-size: 11px;
      font-weight: 500;
      border-radius: var(--radius-full);
      background: rgba(22, 27, 34, 0.9);
      backdrop-filter: blur(8px);
      border: 1px solid var(--border-default);
      color: var(--fg-muted);
      cursor: pointer;
      transition: all var(--duration-fast) var(--easing);
    }

    .task-filter-chip:hover { border-color: var(--fg-subtle); color: var(--fg-default); }
    .task-filter-chip.active { border-color: var(--accent-fg); color: var(--accent-fg); background: var(--accent-muted); }

    .task-filter-chip .count {
      font-family: var(--font-mono);
      font-size: 10px;
      margin-left: 4px;
      opacity: 0.7;
    }

    /* SVG Canvas */
    #orbit-svg {
      width: 100%;
      height: 100%;
      cursor: grab;
    }
    #orbit-svg.dragging { cursor: grabbing; }

    /* ========================================
       SVG Styles
       ======================================== */
    .orbit-ring {
      fill: none;
      stroke: rgba(48, 54, 61, 0.3);
      stroke-width: 1;
      stroke-dasharray: 4 6;
    }

    .task-cluster-label {
      font-family: var(--font-sans);
      font-size: 10px;
      font-weight: 600;
      fill: var(--fg-subtle);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .task-cluster-priority {
      font-family: var(--font-mono);
      font-size: 9px;
      font-weight: 500;
    }

    .arc-connection {
      fill: none;
      stroke-width: 1.5;
      opacity: 0.3;
    }

    .arc-connection.active {
      opacity: 0.7;
      stroke-width: 2;
    }

    .arc-connection.completed {
      opacity: 0.4;
    }

    .agent-node { cursor: pointer; }
    .agent-node:hover .node-ring { opacity: 1; }

    .node-bg {
      stroke-width: 2;
      transition: all var(--duration-fast) var(--easing);
    }

    .node-ring {
      fill: none;
      stroke-width: 1;
      opacity: 0;
      transition: opacity var(--duration-fast) var(--easing);
    }

    .node-icon {
      font-size: 14px;
      text-anchor: middle;
      dominant-baseline: central;
      fill: var(--bg-canvas);
      font-weight: 600;
    }

    .node-label {
      font-family: var(--font-sans);
      font-size: 9px;
      font-weight: 500;
      fill: var(--fg-muted);
      text-anchor: middle;
    }

    .node-status-dot {
      r: 4;
      stroke: var(--bg-canvas);
      stroke-width: 2;
    }

    .node-token-ring {
      fill: none;
      stroke-width: 2;
      stroke-linecap: round;
      opacity: 0.4;
    }

    /* Decision badge on nodes */
    .decision-badge { cursor: pointer; }

    .decision-badge-bg {
      rx: 4;
      ry: 4;
      stroke-width: 1;
    }

    .decision-badge-icon {
      font-size: 9px;
      text-anchor: middle;
      dominant-baseline: central;
      font-weight: 600;
    }

    /* Particle animation for active arcs */
    .flow-particle {
      r: 2;
      opacity: 0.9;
    }

    /* Node selected state */
    .agent-node.selected .node-ring { opacity: 1; stroke-width: 2; }
    .agent-node.selected .node-bg { stroke-width: 3; }

    /* Pulse animation for running nodes */
    @keyframes nodePulse {
      0%, 100% { opacity: 0.15; r: 22; }
      50% { opacity: 0.3; r: 26; }
    }

    .running-pulse {
      animation: nodePulse 2s ease-in-out infinite;
    }

    /* Decision pulse */
    @keyframes decisionPulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }

    .decision-badge { animation: decisionPulse 2s ease-in-out infinite; }

    /* ========================================
       Detail Panel (360px)
       ======================================== */
    .detail-panel {
      width: 360px;
      min-width: 360px;
      background: var(--bg-default);
      border-left: 1px solid var(--border-default);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .panel-empty {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      gap: 12px;
      color: var(--fg-subtle);
    }

    .panel-empty-icon {
      font-size: 32px;
      opacity: 0.4;
    }

    .panel-empty-text {
      font-size: 13px;
      text-align: center;
      line-height: 1.5;
    }

    .panel-empty-hint {
      font-size: 11px;
      color: var(--fg-subtle);
      opacity: 0.6;
    }

    .panel-header {
      padding: 16px;
      border-bottom: 1px solid var(--border-default);
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }

    .panel-agent-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      font-weight: 700;
      color: var(--bg-canvas);
      flex-shrink: 0;
    }

    .panel-agent-info {
      flex: 1;
      min-width: 0;
    }

    .panel-agent-name {
      font-size: 15px;
      font-weight: 600;
      color: var(--fg-default);
      margin-bottom: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .panel-agent-meta {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
    }

    .panel-agent-type {
      color: var(--fg-muted);
      text-transform: capitalize;
    }

    .panel-close {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-sm);
      color: var(--fg-subtle);
      transition: all var(--duration-fast) var(--easing);
      flex-shrink: 0;
    }

    .panel-close:hover { background: var(--bg-subtle); color: var(--fg-default); }

    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      border-radius: var(--radius-full);
      font-size: 11px;
      font-weight: 500;
    }

    .status-badge .dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
    }

    .status-badge.completed { background: rgba(167, 139, 250, 0.15); color: #A78BFA; }
    .status-badge.completed .dot { background: #A78BFA; }
    .status-badge.running { background: rgba(52, 211, 153, 0.15); color: #34D399; }
    .status-badge.running .dot { background: #34D399; }
    .status-badge.verifying { background: rgba(255, 216, 102, 0.15); color: #FFD866; }
    .status-badge.verifying .dot { background: #FFD866; }
    .status-badge.blocked { background: rgba(252, 165, 114, 0.15); color: #FCA572; }
    .status-badge.blocked .dot { background: #FCA572; }
    .status-badge.failed { background: rgba(248, 113, 113, 0.15); color: #F87171; }
    .status-badge.failed .dot { background: #F87171; }
    .status-badge.queued { background: rgba(71, 85, 105, 0.25); color: #8b949e; }
    .status-badge.queued .dot { background: #475569; }

    /* Panel tabs */
    .panel-tabs {
      display: flex;
      border-bottom: 1px solid var(--border-default);
      padding: 0 16px;
    }

    .panel-tab {
      padding: 8px 12px;
      font-size: 12px;
      font-weight: 500;
      color: var(--fg-subtle);
      border-bottom: 2px solid transparent;
      margin-bottom: -1px;
      transition: all var(--duration-fast) var(--easing);
      cursor: pointer;
    }

    .panel-tab:hover { color: var(--fg-muted); }
    .panel-tab.active { color: var(--fg-default); border-bottom-color: var(--accent-fg); }

    .panel-tab-content {
      display: none;
      overflow-y: auto;
      flex: 1;
    }
    .panel-tab-content.active { display: block; }

    .panel-body {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .panel-section {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border-muted);
    }

    .panel-section-title {
      font-size: 10px;
      font-weight: 600;
      color: var(--fg-subtle);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 8px;
    }

    .stat-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .stat-item {
      padding: 8px;
      background: var(--bg-subtle);
      border-radius: var(--radius);
      border: 1px solid var(--border-muted);
    }

    .stat-label {
      font-size: 10px;
      color: var(--fg-subtle);
      margin-bottom: 2px;
    }

    .stat-value {
      font-size: 14px;
      font-weight: 600;
      font-family: var(--font-mono);
      color: var(--fg-default);
    }

    .stat-value.cost { color: var(--color-orchestrator); }

    .progress-bar-container {
      height: 6px;
      background: var(--bg-emphasis);
      border-radius: var(--radius-full);
      overflow: hidden;
      margin-top: 6px;
    }

    .progress-bar-fill {
      height: 100%;
      border-radius: var(--radius-full);
      transition: width 0.5s var(--easing);
    }

    /* Relationships */
    .relationship-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 0;
    }

    .relationship-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .relationship-name {
      font-size: 12px;
      color: var(--fg-default);
      flex: 1;
    }

    .relationship-status {
      font-size: 10px;
      color: var(--fg-subtle);
    }

    .relationship-arrow {
      font-size: 10px;
      color: var(--fg-subtle);
      margin-right: 2px;
    }

    /* Decision feed items */
    .decision-feed-item {
      display: flex;
      gap: 8px;
      padding: 8px 0;
      cursor: pointer;
      border-radius: var(--radius-sm);
      transition: background var(--duration-fast) var(--easing);
    }

    .decision-feed-item:hover { background: var(--bg-subtle); margin: 0 -4px; padding: 8px 4px; }

    .decision-feed-icon {
      width: 24px;
      height: 24px;
      border-radius: var(--radius-sm);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      flex-shrink: 0;
    }

    .decision-feed-content {
      flex: 1;
      min-width: 0;
    }

    .decision-feed-type {
      font-size: 11px;
      font-weight: 600;
      margin-bottom: 1px;
    }

    .decision-feed-summary {
      font-size: 11px;
      color: var(--fg-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .decision-feed-time {
      font-size: 10px;
      font-family: var(--font-mono);
      color: var(--fg-subtle);
      flex-shrink: 0;
    }

    /* Activity items */
    .activity-item {
      display: flex;
      gap: 10px;
      padding: 6px 0;
      font-size: 12px;
    }

    .activity-time {
      font-family: var(--font-mono);
      font-size: 10px;
      color: var(--fg-subtle);
      min-width: 36px;
      flex-shrink: 0;
    }

    .activity-text {
      color: var(--fg-muted);
      line-height: 1.4;
    }

    .activity-text strong {
      color: var(--fg-default);
      font-weight: 500;
    }

    /* ========================================
       Decision Popover
       ======================================== */
    .popover-overlay {
      position: fixed;
      inset: 0;
      z-index: 100;
    }

    .decision-popover {
      position: fixed;
      width: 340px;
      background: var(--bg-default);
      border: 1px solid var(--border-default);
      border-radius: var(--radius-lg);
      box-shadow: 0 16px 48px rgba(0, 0, 0, 0.35);
      z-index: 101;
      overflow: hidden;
      animation: popoverIn 0.2s var(--easing);
    }

    @keyframes popoverIn {
      from { opacity: 0; transform: scale(0.95) translateY(-4px); }
      to { opacity: 1; transform: scale(1) translateY(0); }
    }

    .popover-header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border-muted);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .popover-icon {
      width: 28px;
      height: 28px;
      border-radius: var(--radius);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    .popover-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--fg-default);
    }

    .popover-subtitle {
      font-size: 11px;
      color: var(--fg-muted);
    }

    .popover-body {
      padding: 12px 16px;
    }

    .popover-section {
      margin-bottom: 12px;
    }
    .popover-section:last-child { margin-bottom: 0; }

    .popover-label {
      font-size: 10px;
      font-weight: 600;
      color: var(--fg-subtle);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 4px;
    }

    .popover-text {
      font-size: 12px;
      color: var(--fg-muted);
      line-height: 1.5;
    }

    .confidence-value {
      font-size: 18px;
      font-weight: 700;
      font-family: var(--font-mono);
      margin-bottom: 4px;
    }

    .confidence-bar-bg {
      height: 4px;
      background: var(--bg-emphasis);
      border-radius: var(--radius-full);
      overflow: hidden;
      margin-bottom: 4px;
    }

    .confidence-bar-fill {
      height: 100%;
      border-radius: var(--radius-full);
      transition: width 0.5s var(--easing);
    }

    .confidence-markers {
      display: flex;
      justify-content: space-between;
      font-size: 9px;
      font-family: var(--font-mono);
      color: var(--fg-subtle);
    }

    .popover-tag-list {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .popover-tag {
      padding: 2px 8px;
      font-size: 10px;
      background: var(--bg-subtle);
      border: 1px solid var(--border-muted);
      border-radius: var(--radius-full);
      color: var(--fg-muted);
    }

    .popover-alternative {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      font-size: 12px;
    }

    .popover-alternative-name { color: var(--fg-muted); }
    .popover-alternative-score { font-family: var(--font-mono); color: var(--fg-subtle); }

    .popover-footer {
      padding: 10px 16px;
      border-top: 1px solid var(--border-muted);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .popover-policy {
      font-size: 10px;
      font-family: var(--font-mono);
      color: var(--fg-subtle);
    }

    .override-btn {
      padding: 4px 12px;
      font-size: 11px;
      font-weight: 500;
      border-radius: var(--radius);
      border: 1px solid var(--border-default);
      color: var(--fg-muted);
      transition: all var(--duration-fast) var(--easing);
    }

    .override-btn:hover {
      border-color: var(--danger-fg);
      color: var(--danger-fg);
      background: rgba(248, 81, 73, 0.1);
    }

    /* Tooltip */
    .tooltip {
      position: fixed;
      background: var(--bg-default);
      border: 1px solid var(--border-default);
      border-radius: var(--radius);
      padding: 8px 12px;
      font-size: 11px;
      color: var(--fg-default);
      pointer-events: none;
      z-index: 200;
      box-shadow: 0 8px 24px rgba(0,0,0,0.3);
      max-width: 220px;
      display: none;
    }

    .tooltip-name {
      font-weight: 600;
      margin-bottom: 2px;
    }

    .tooltip-meta {
      color: var(--fg-muted);
      font-size: 10px;
    }

    .tooltip-stat {
      display: flex;
      justify-content: space-between;
      margin-top: 4px;
      font-family: var(--font-mono);
      font-size: 10px;
    }

    .tooltip-stat .lbl { color: var(--fg-subtle); }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--bg-emphasis); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--fg-subtle); }
  </style>
</head>
<body>
  <div class="page">
    <!-- Header -->
    <div class="header">
      <div class="header-left">
        <div class="logo">
          <div class="logo-icon">A</div>
          AgentFlow
          <span class="logo-badge">RADIAL</span>
        </div>
      </div>

      <div class="header-center">
        <div class="sim-controls">
          <button class="sim-btn active" id="sim-play" title="Play/Pause">&#9654;</button>
          <button class="sim-btn" id="sim-reset" title="Reset">&#8634;</button>
          <div class="separator" style="width:1px;height:20px;background:var(--border-default);margin:0 4px"></div>
          <button class="speed-btn active" data-speed="1">1x</button>
          <button class="speed-btn" data-speed="2">2x</button>
          <button class="speed-btn" data-speed="4">4x</button>
          <button class="speed-btn" data-speed="8">8x</button>
        </div>
      </div>

      <div class="header-right">
        <div class="metric-pill">
          <span class="label">Active</span>
          <span class="value running" id="metric-active">0</span>
          <span class="label">/</span>
          <span class="value" id="metric-total">33</span>
        </div>
        <div class="metric-pill">
          <span class="label">Tokens</span>
          <span class="value" id="metric-tokens">0</span>
        </div>
        <div class="metric-pill">
          <span class="label">Cost</span>
          <span class="value cost" id="metric-cost">$0.00</span>
        </div>
        <div class="metric-pill">
          <span class="label">Decisions</span>
          <span class="value" id="metric-decisions">0</span>
        </div>
      </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
      <!-- Canvas -->
      <div class="canvas-area">
        <div class="canvas-toolbar">
          <button id="zoom-in" title="Zoom In">+</button>
          <button id="zoom-out" title="Zoom Out">&minus;</button>
          <button id="zoom-fit" title="Fit to View">&#9632;</button>
          <div class="separator"></div>
          <button id="toggle-labels" class="active" title="Toggle Labels">T</button>
        </div>

        <div class="task-filter-bar" id="task-filters"></div>
        <div class="zoom-indicator" id="zoom-label">100%</div>

        <svg id="orbit-svg">
          <defs>
            <!-- Glow filters -->
            <filter id="glow-running" x="-50%" y="-50%" width="200%" height="200%">
              <feGaussianBlur stdDeviation="3" result="blur"/>
              <feMerge>
                <feMergeNode in="blur"/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>
            <filter id="glow-verifying" x="-50%" y="-50%" width="200%" height="200%">
              <feGaussianBlur stdDeviation="2" result="blur"/>
              <feMerge>
                <feMergeNode in="blur"/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>
            <filter id="arc-glow" x="-50%" y="-50%" width="200%" height="200%">
              <feGaussianBlur stdDeviation="2" result="blur"/>
              <feMerge>
                <feMergeNode in="blur"/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>
          </defs>
          <g id="transform-group">
            <g id="orbit-rings-layer"></g>
            <g id="arcs-layer"></g>
            <g id="particles-layer"></g>
            <g id="nodes-layer"></g>
            <g id="decisions-layer"></g>
            <g id="labels-layer"></g>
          </g>
        </svg>
      </div>

      <!-- Detail Panel -->
      <div class="detail-panel" id="detail-panel">
        <div class="panel-empty" id="panel-empty">
          <div class="panel-empty-icon">&#9673;</div>
          <div class="panel-empty-text">Select an agent node<br>to view details</div>
          <div class="panel-empty-hint">Click any orbiting node on the canvas</div>
        </div>
        <div id="panel-content" style="display:none;flex-direction:column;flex:1;overflow:hidden">
          <div class="panel-header" id="panel-header"></div>
          <div class="panel-tabs">
            <div class="panel-tab active" data-tab="details">Details</div>
            <div class="panel-tab" data-tab="decisions">Decisions</div>
            <div class="panel-tab" data-tab="activity">Activity</div>
          </div>
          <div id="tab-details" class="panel-tab-content active"></div>
          <div id="tab-decisions" class="panel-tab-content"></div>
          <div id="tab-activity" class="panel-tab-content"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Tooltip -->
  <div class="tooltip" id="tooltip">
    <div class="tooltip-name" id="tooltip-name"></div>
    <div class="tooltip-meta" id="tooltip-meta"></div>
    <div class="tooltip-stat"><span class="lbl">Tokens</span><span id="tooltip-tokens">0</span></div>
    <div class="tooltip-stat"><span class="lbl">Progress</span><span id="tooltip-progress">0%</span></div>
  </div>

  <!-- Popover container -->
  <div id="popover-container"></div>

  <script>
    // ========================================
    // DATA: AGENT TYPES
    // ========================================
    const AGENT_TYPES = {
      orchestrator: { color: '#FFD866', symbol: 'O', label: 'Orchestrator' },
      planner:      { color: '#A78BFA', symbol: 'P', label: 'Planner' },
      coder:        { color: '#67E8F9', symbol: 'C', label: 'Coder' },
      reviewer:     { color: '#C084FC', symbol: 'R', label: 'Reviewer' },
      tester:       { color: '#FCA572', symbol: 'T', label: 'Tester' },
      scanner:      { color: '#F87171', symbol: 'S', label: 'Scanner' },
      deployer:     { color: '#34D399', symbol: 'D', label: 'Deployer' }
    };

    const STATUS_COLORS = {
      completed: '#A78BFA',
      running:   '#34D399',
      verifying: '#FFD866',
      blocked:   '#FCA572',
      failed:    '#F87171',
      queued:    '#475569'
    };

    const DECISION_TYPES = {
      auto_verify:  { icon: '\u26A1', color: '#34D399', label: 'Auto Verify' },
      route:        { icon: '\u2461', color: '#67E8F9', label: 'Route' },
      retry:        { icon: '\u21BB', color: '#FCA572', label: 'Retry' },
      escalate:     { icon: '\u25B2', color: '#F87171', label: 'Escalate' },
      spawn:        { icon: '\u25C7', color: '#A78BFA', label: 'Spawn' },
      tool_select:  { icon: '\u2699', color: '#FFD866', label: 'Tool Select' },
      delegate:     { icon: '\u2192', color: '#67E8F9', label: 'Delegate' },
      throttle:     { icon: '\u25D1', color: '#FCA572', label: 'Throttle' },
      prioritize:   { icon: '\u2605', color: '#FFD866', label: 'Prioritize' }
    };

    // ========================================
    // DATA: TASKS (6 tasks, 33 agents total)
    // ========================================
    const TASKS = [
      {
        id: 'api-platform',
        name: 'API Platform v2',
        priority: 'P0',
        priorityColor: '#F87171',
        agents: [
          { id: 'ap-orch', name: 'Orchestrator', type: 'orchestrator', children: ['ap-plan'], depth: 0 },
          { id: 'ap-plan', name: 'Planner', type: 'planner', children: ['ap-coder1', 'ap-coder2', 'ap-coder3'], depth: 1 },
          { id: 'ap-coder1', name: 'API Coder', type: 'coder', children: ['ap-rev1'], depth: 2 },
          { id: 'ap-coder2', name: 'Schema Coder', type: 'coder', children: ['ap-rev1'], depth: 2 },
          { id: 'ap-coder3', name: 'Auth Coder', type: 'coder', children: ['ap-rev2'], depth: 2 },
          { id: 'ap-rev1', name: 'Code Reviewer', type: 'reviewer', children: ['ap-test1'], depth: 3 },
          { id: 'ap-rev2', name: 'Security Rev', type: 'reviewer', children: ['ap-test2'], depth: 3 },
          { id: 'ap-test1', name: 'Integration', type: 'tester', children: ['ap-scan'], depth: 4 },
          { id: 'ap-test2', name: 'Auth Tester', type: 'tester', children: ['ap-scan'], depth: 4 },
          { id: 'ap-scan', name: 'Scanner', type: 'scanner', children: [], depth: 5 }
        ]
      },
      {
        id: 'auth-migration',
        name: 'Auth Migration',
        priority: 'P0',
        priorityColor: '#F87171',
        agents: [
          { id: 'am-orch', name: 'Orchestrator', type: 'orchestrator', children: ['am-coder1', 'am-coder2'], depth: 0 },
          { id: 'am-coder1', name: 'OAuth Coder', type: 'coder', children: ['am-rev'], depth: 1 },
          { id: 'am-coder2', name: 'Session Coder', type: 'coder', children: ['am-rev'], depth: 1 },
          { id: 'am-rev', name: 'Reviewer', type: 'reviewer', children: ['am-test'], depth: 2 },
          { id: 'am-test', name: 'Tester', type: 'tester', children: [], depth: 3 }
        ]
      },
      {
        id: 'terraform-refactor',
        name: 'Terraform Refactor',
        priority: 'P1',
        priorityColor: '#FFD866',
        agents: [
          { id: 'tf-orch', name: 'Orchestrator', type: 'orchestrator', children: ['tf-plan'], depth: 0 },
          { id: 'tf-plan', name: 'Planner', type: 'planner', children: ['tf-coder1', 'tf-coder2'], depth: 1 },
          { id: 'tf-coder1', name: 'Module Coder', type: 'coder', children: ['tf-rev'], depth: 2 },
          { id: 'tf-coder2', name: 'State Coder', type: 'coder', children: ['tf-rev'], depth: 2 },
          { id: 'tf-rev', name: 'Reviewer', type: 'reviewer', children: ['tf-test'], depth: 3 },
          { id: 'tf-test', name: 'Plan Tester', type: 'tester', children: [], depth: 4 }
        ]
      },
      {
        id: 'dashboard-redesign',
        name: 'Dashboard Redesign',
        priority: 'P1',
        priorityColor: '#FFD866',
        agents: [
          { id: 'dr-orch', name: 'Orchestrator', type: 'orchestrator', children: ['dr-coder1', 'dr-coder2'], depth: 0 },
          { id: 'dr-coder1', name: 'Layout Coder', type: 'coder', children: ['dr-rev'], depth: 1 },
          { id: 'dr-coder2', name: 'Chart Coder', type: 'coder', children: ['dr-rev'], depth: 1 },
          { id: 'dr-rev', name: 'UX Reviewer', type: 'reviewer', children: ['dr-test'], depth: 2 },
          { id: 'dr-test', name: 'Visual Tester', type: 'tester', children: [], depth: 3 }
        ]
      },
      {
        id: 'data-pipeline',
        name: 'Data Pipeline ETL',
        priority: 'P0',
        priorityColor: '#F87171',
        agents: [
          { id: 'dp-orch', name: 'Orchestrator', type: 'orchestrator', children: ['dp-coder1'], depth: 0 },
          { id: 'dp-coder1', name: 'Extract Coder', type: 'coder', children: ['dp-coder2'], depth: 1 },
          { id: 'dp-coder2', name: 'Transform Coder', type: 'coder', children: ['dp-coder3'], depth: 2 },
          { id: 'dp-coder3', name: 'Load Coder', type: 'coder', children: ['dp-test'], depth: 3 },
          { id: 'dp-test', name: 'ETL Tester', type: 'tester', children: [], depth: 4 }
        ]
      },
      {
        id: 'ci-optimization',
        name: 'CI Optimization',
        priority: 'P2',
        priorityColor: '#67E8F9',
        agents: [
          { id: 'ci-coder', name: 'CI Coder', type: 'coder', children: ['ci-test'], depth: 0 },
          { id: 'ci-test', name: 'CI Tester', type: 'tester', children: [], depth: 1 }
        ]
      }
    ];

    // ========================================
    // SIMULATION STATE
    // ========================================
    let simState = {
      running: true,
      speed: 1,
      tick: 0,
      agents: {},
      decisions: [],
      totalTokens: 0,
      totalCost: 0,
      selectedAgent: null,
      hoveredAgent: null,
      showLabels: true,
      activeFilters: new Set(),
      zoom: 1,
      panX: 0,
      panY: 0,
      viewBox: { x: 0, y: 0, w: 0, h: 0 },
      clusterPositions: {} // center positions for each task cluster
    };

    // ========================================
    // INITIALIZE AGENT STATES
    // ========================================
    function initAgentStates() {
      for (const task of TASKS) {
        for (const agent of task.agents) {
          simState.agents[agent.id] = {
            ...agent,
            taskId: task.id,
            taskName: task.name,
            status: 'queued',
            progress: 0,
            tokens: 0,
            cost: 0,
            messages: 0,
            turns: 0,
            startedAt: null,
            decisions: [],
            verified: false,
            verificationScore: 0,
            x: 0, y: 0,
            orbitAngle: 0, // current orbit angle in radians
            orbitSpeed: 0.002 + Math.random() * 0.003, // radians per frame
            baseAngle: 0, // initial angle position on ring
            radius: 18,
            tokenRate: 800 + Math.random() * 2000,
            nodeSize: 16
          };
        }
      }
    }

    // ========================================
    // HEXAGONAL GRID LAYOUT FOR CLUSTERS
    // ========================================
    function computeClusterLayout() {
      const svg = document.getElementById('orbit-svg');
      const rect = svg.getBoundingClientRect();
      const canvasW = rect.width;
      const canvasH = rect.height;

      // Hexagonal grid parameters
      const cols = 3;
      const rows = 2;
      const clusterSpacingX = canvasW / (cols + 0.5);
      const clusterSpacingY = canvasH / (rows + 0.5);
      const startX = clusterSpacingX * 0.75;
      const startY = clusterSpacingY * 0.65;

      // Hexagonal offset: odd rows shifted right
      const positions = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const offsetX = (r % 2 === 1) ? clusterSpacingX * 0.5 : 0;
          positions.push({
            x: startX + c * clusterSpacingX + offsetX,
            y: startY + r * clusterSpacingY
          });
        }
      }

      // Assign cluster centers
      for (let i = 0; i < TASKS.length; i++) {
        const task = TASKS[i];
        const pos = positions[i] || { x: canvasW / 2, y: canvasH / 2 };
        simState.clusterPositions[task.id] = {
          cx: pos.x,
          cy: pos.y,
          task: task
        };

        // Compute max depth for ring sizing
        let maxDepth = 0;
        for (const agent of task.agents) {
          maxDepth = Math.max(maxDepth, agent.depth);
        }

        const ringSpacing = Math.min(clusterSpacingX, clusterSpacingY) * 0.13;
        simState.clusterPositions[task.id].maxDepth = maxDepth;
        simState.clusterPositions[task.id].ringSpacing = ringSpacing;

        // Place agents on their concentric rings
        // Group agents by depth
        const depthGroups = {};
        for (const agent of task.agents) {
          if (!depthGroups[agent.depth]) depthGroups[agent.depth] = [];
          depthGroups[agent.depth].push(agent.id);
        }

        for (const [depthStr, ids] of Object.entries(depthGroups)) {
          const depth = parseInt(depthStr);
          const ringR = depth * ringSpacing;
          const count = ids.length;

          for (let j = 0; j < count; j++) {
            const baseAngle = (2 * Math.PI * j) / count - Math.PI / 2;
            const agentState = simState.agents[ids[j]];
            if (agentState) {
              agentState.baseAngle = baseAngle;
              agentState.orbitAngle = baseAngle;
              if (depth === 0) {
                // Orchestrator at center
                agentState.x = pos.x;
                agentState.y = pos.y;
              } else {
                agentState.x = pos.x + Math.cos(baseAngle) * ringR;
                agentState.y = pos.y + Math.sin(baseAngle) * ringR;
              }
              agentState.clusterCx = pos.x;
              agentState.clusterCy = pos.y;
              agentState.orbitRadius = ringR;
            }
          }
        }
      }
    }

    // ========================================
    // UPDATE ORBITAL POSITIONS
    // ========================================
    function updateOrbits() {
      for (const id of Object.keys(simState.agents)) {
        const agent = simState.agents[id];
        if (agent.depth === 0) continue; // center node doesn't orbit

        // Only orbit while running
        if (agent.status === 'running' || agent.status === 'verifying') {
          agent.orbitAngle += agent.orbitSpeed * simState.speed;
        }

        const cluster = simState.clusterPositions[agent.taskId];
        if (!cluster) continue;
        const r = agent.orbitRadius;
        agent.x = cluster.cx + Math.cos(agent.orbitAngle) * r;
        agent.y = cluster.cy + Math.sin(agent.orbitAngle) * r;
      }
    }

    // ========================================
    // SVG RENDERING
    // ========================================
    function renderOrbitRings() {
      const layer = document.getElementById('orbit-rings-layer');
      layer.innerHTML = '';

      for (const taskId of Object.keys(simState.clusterPositions)) {
        const cluster = simState.clusterPositions[taskId];
        const task = cluster.task;

        // Draw concentric orbit rings
        for (let d = 1; d <= cluster.maxDepth; d++) {
          const r = d * cluster.ringSpacing;
          const ring = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          ring.setAttribute('cx', cluster.cx);
          ring.setAttribute('cy', cluster.cy);
          ring.setAttribute('r', r);
          ring.setAttribute('class', 'orbit-ring');

          // Dim if filtered
          if (simState.activeFilters.size > 0 && !simState.activeFilters.has(taskId)) {
            ring.style.opacity = '0.08';
          }

          layer.appendChild(ring);
        }

        // Subtle background glow for cluster
        const glowR = (cluster.maxDepth + 0.5) * cluster.ringSpacing;
        const glow = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        glow.setAttribute('cx', cluster.cx);
        glow.setAttribute('cy', cluster.cy);
        glow.setAttribute('r', glowR);
        glow.setAttribute('fill', `url(#cluster-glow-${taskId})`);
        glow.style.opacity = simState.activeFilters.size > 0 && !simState.activeFilters.has(taskId) ? '0.03' : '0.06';
        layer.appendChild(glow);

        // Add radial gradient defs
        const svg = document.getElementById('orbit-svg');
        const defs = svg.querySelector('defs');
        if (!document.getElementById(`cluster-glow-${taskId}`)) {
          const grad = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
          grad.id = `cluster-glow-${taskId}`;
          const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
          stop1.setAttribute('offset', '0%');
          stop1.setAttribute('stop-color', task.priorityColor);
          stop1.setAttribute('stop-opacity', '0.15');
          const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
          stop2.setAttribute('offset', '100%');
          stop2.setAttribute('stop-color', task.priorityColor);
          stop2.setAttribute('stop-opacity', '0');
          grad.appendChild(stop1);
          grad.appendChild(stop2);
          defs.appendChild(grad);
        }

        // Cluster label
        const labelY = cluster.cy - glowR - 10;
        const dimmed = simState.activeFilters.size > 0 && !simState.activeFilters.has(taskId);

        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', cluster.cx);
        label.setAttribute('y', labelY);
        label.setAttribute('class', 'task-cluster-label');
        label.setAttribute('text-anchor', 'middle');
        label.textContent = task.name;
        label.style.opacity = dimmed ? '0.15' : '1';
        layer.appendChild(label);

        // Priority badge
        const pri = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        pri.setAttribute('x', cluster.cx);
        pri.setAttribute('y', labelY + 13);
        pri.setAttribute('class', 'task-cluster-priority');
        pri.setAttribute('text-anchor', 'middle');
        pri.setAttribute('fill', task.priorityColor);
        pri.textContent = task.priority;
        pri.style.opacity = dimmed ? '0.15' : '0.7';
        layer.appendChild(pri);
      }
    }

    function renderArcs() {
      const layer = document.getElementById('arcs-layer');
      layer.innerHTML = '';

      for (const task of TASKS) {
        const dimmed = simState.activeFilters.size > 0 && !simState.activeFilters.has(task.id);

        for (const agent of task.agents) {
          for (const childId of agent.children) {
            const parent = simState.agents[agent.id];
            const child = simState.agents[childId];
            if (!parent || !child) continue;

            // Draw curved arc from parent to child
            const dx = child.x - parent.x;
            const dy = child.y - parent.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Curved path with control point offset
            const mx = (parent.x + child.x) / 2;
            const my = (parent.y + child.y) / 2;
            // Perpendicular offset for curve
            const nx = -dy / dist;
            const ny = dx / dist;
            const curvature = dist * 0.15;
            const cpx = mx + nx * curvature;
            const cpy = my + ny * curvature;

            const d = `M ${parent.x} ${parent.y} Q ${cpx} ${cpy} ${child.x} ${child.y}`;

            const arc = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            arc.setAttribute('d', d);
            arc.setAttribute('data-from', agent.id);
            arc.setAttribute('data-to', childId);

            // Determine status for arc
            let isActive = false;
            let isComplete = false;
            let arcColor = '#30363d';

            if (parent.status === 'completed' && (child.status === 'running' || child.status === 'verifying' || child.status === 'completed')) {
              isComplete = true;
              arcColor = '#A78BFA';
            }
            if (parent.status === 'running' || child.status === 'running') {
              isActive = true;
              arcColor = '#34D399';
            }
            if (parent.status === 'completed' && child.status === 'running') {
              isActive = true;
              arcColor = '#34D399';
            }

            arc.setAttribute('class', `arc-connection ${isActive ? 'active' : ''} ${isComplete ? 'completed' : ''}`);
            arc.setAttribute('stroke', arcColor);
            arc.setAttribute('fill', 'none');

            if (isActive) {
              arc.setAttribute('filter', 'url(#arc-glow)');
              arc.style.opacity = '0.8';
              arc.style.strokeWidth = '2';
            } else if (isComplete) {
              arc.style.opacity = '0.35';
            } else {
              arc.style.opacity = dimmed ? '0.05' : '0.15';
              arc.style.strokeDasharray = '3 5';
            }

            layer.appendChild(arc);
          }
        }
      }
    }

    function renderParticles() {
      const layer = document.getElementById('particles-layer');
      layer.innerHTML = '';

      for (const task of TASKS) {
        if (simState.activeFilters.size > 0 && !simState.activeFilters.has(task.id)) continue;

        for (const agent of task.agents) {
          for (const childId of agent.children) {
            const parent = simState.agents[agent.id];
            const child = simState.agents[childId];
            if (!parent || !child) continue;

            // Only show particles on active connections
            const isActive = (parent.status === 'completed' && child.status === 'running') ||
                             (parent.status === 'running' && child.status === 'running');
            if (!isActive) continue;

            // Create 2-3 particles per active arc
            const numParticles = 2 + Math.floor(Math.random() * 2);
            for (let p = 0; p < numParticles; p++) {
              const t = ((simState.tick * 0.02 * simState.speed + p * (1 / numParticles)) % 1);

              // Quadratic bezier interpolation
              const dx = child.x - parent.x;
              const dy = child.y - parent.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const nx = -dy / dist;
              const ny = dx / dist;
              const curvature = dist * 0.15;
              const mx = (parent.x + child.x) / 2 + nx * curvature;
              const my = (parent.y + child.y) / 2 + ny * curvature;

              // Quadratic bezier: B(t) = (1-t)^2*P0 + 2(1-t)t*P1 + t^2*P2
              const omt = 1 - t;
              const px = omt * omt * parent.x + 2 * omt * t * mx + t * t * child.x;
              const py = omt * omt * parent.y + 2 * omt * t * my + t * t * child.y;

              const particle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
              particle.setAttribute('cx', px);
              particle.setAttribute('cy', py);
              particle.setAttribute('r', 2);
              particle.setAttribute('fill', '#34D399');
              particle.setAttribute('class', 'flow-particle');
              particle.style.opacity = 0.4 + Math.sin(t * Math.PI) * 0.5;
              layer.appendChild(particle);
            }
          }
        }
      }
    }

    function renderNodes() {
      const layer = document.getElementById('nodes-layer');
      layer.innerHTML = '';

      for (const id of Object.keys(simState.agents)) {
        const agent = simState.agents[id];
        const typeInfo = AGENT_TYPES[agent.type];
        const statusColor = STATUS_COLORS[agent.status] || STATUS_COLORS.queued;
        const dimmed = simState.activeFilters.size > 0 && !simState.activeFilters.has(agent.taskId);

        // Dynamic node size based on tokens
        const nodeSize = Math.max(14, Math.min(24, 14 + (agent.tokens / 60000) * 10));
        // Orchestrators slightly bigger
        const finalSize = agent.type === 'orchestrator' ? nodeSize + 4 : nodeSize;
        agent.nodeSize = finalSize;

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('class', `agent-node ${simState.selectedAgent === id ? 'selected' : ''}`);
        g.setAttribute('data-id', id);
        g.setAttribute('transform', `translate(${agent.x}, ${agent.y})`);
        g.style.opacity = dimmed ? '0.12' : '1';

        // Running pulse
        if (agent.status === 'running' && !dimmed) {
          const pulse = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          pulse.setAttribute('cx', 0);
          pulse.setAttribute('cy', 0);
          pulse.setAttribute('r', finalSize + 4);
          pulse.setAttribute('fill', statusColor);
          pulse.setAttribute('class', 'running-pulse');
          g.appendChild(pulse);
        }

        // Token usage ring (background)
        if (agent.tokens > 0) {
          const ringBg = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          ringBg.setAttribute('cx', 0);
          ringBg.setAttribute('cy', 0);
          ringBg.setAttribute('r', finalSize + 3);
          ringBg.setAttribute('fill', 'none');
          ringBg.setAttribute('stroke', '#21262d');
          ringBg.setAttribute('stroke-width', '2');
          g.appendChild(ringBg);

          const circumference = 2 * Math.PI * (finalSize + 3);
          const tokenPct = Math.min(1, agent.tokens / 100000);
          const ring = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          ring.setAttribute('cx', 0);
          ring.setAttribute('cy', 0);
          ring.setAttribute('r', finalSize + 3);
          ring.setAttribute('class', 'node-token-ring');
          ring.setAttribute('stroke', typeInfo.color);
          ring.setAttribute('stroke-dasharray', `${circumference * tokenPct} ${circumference * (1 - tokenPct)}`);
          ring.setAttribute('transform', 'rotate(-90)');
          g.appendChild(ring);
        }

        // Selection ring
        const selRing = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        selRing.setAttribute('cx', 0);
        selRing.setAttribute('cy', 0);
        selRing.setAttribute('r', finalSize + 7);
        selRing.setAttribute('stroke', typeInfo.color);
        selRing.setAttribute('class', 'node-ring');
        g.appendChild(selRing);

        // Main circle
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', 0);
        circle.setAttribute('cy', 0);
        circle.setAttribute('r', finalSize);
        circle.setAttribute('fill', typeInfo.color);
        circle.setAttribute('stroke', statusColor);
        circle.setAttribute('class', 'node-bg');
        if (agent.status === 'running') circle.setAttribute('filter', 'url(#glow-running)');
        if (agent.status === 'verifying') circle.setAttribute('filter', 'url(#glow-verifying)');
        g.appendChild(circle);

        // Icon
        const icon = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        icon.setAttribute('x', 0);
        icon.setAttribute('y', 0);
        icon.setAttribute('class', 'node-icon');
        icon.setAttribute('font-size', Math.max(10, finalSize * 0.65));
        icon.textContent = typeInfo.symbol;
        g.appendChild(icon);

        // Status dot
        const statusDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        statusDot.setAttribute('cx', finalSize * 0.7);
        statusDot.setAttribute('cy', -finalSize * 0.7);
        statusDot.setAttribute('class', 'node-status-dot');
        statusDot.setAttribute('fill', statusColor);
        g.appendChild(statusDot);

        // Progress bar under node
        if (agent.progress > 0 && agent.status !== 'completed') {
          const barW = 28;
          const barBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          barBg.setAttribute('x', -barW / 2);
          barBg.setAttribute('y', finalSize + 16);
          barBg.setAttribute('width', barW);
          barBg.setAttribute('height', 2);
          barBg.setAttribute('rx', 1);
          barBg.setAttribute('fill', '#21262d');
          g.appendChild(barBg);

          const barFill = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          barFill.setAttribute('x', -barW / 2);
          barFill.setAttribute('y', finalSize + 16);
          barFill.setAttribute('width', barW * (agent.progress / 100));
          barFill.setAttribute('height', 2);
          barFill.setAttribute('rx', 1);
          barFill.setAttribute('fill', statusColor);
          g.appendChild(barFill);
        }

        // Events
        g.addEventListener('mouseenter', (e) => showTooltip(id, e));
        g.addEventListener('mouseleave', hideTooltip);
        g.addEventListener('click', (e) => { e.stopPropagation(); selectAgent(id); });

        layer.appendChild(g);
      }
    }

    function renderLabels() {
      const layer = document.getElementById('labels-layer');
      layer.innerHTML = '';

      if (!simState.showLabels) return;

      for (const id of Object.keys(simState.agents)) {
        const agent = simState.agents[id];
        const dimmed = simState.activeFilters.size > 0 && !simState.activeFilters.has(agent.taskId);
        if (dimmed) continue;

        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', agent.x);
        label.setAttribute('y', agent.y + agent.nodeSize + 13);
        label.setAttribute('class', 'node-label');
        label.textContent = agent.name.length > 12 ? agent.name.substring(0, 10) + '..' : agent.name;
        layer.appendChild(label);
      }
    }

    function renderDecisions() {
      const layer = document.getElementById('decisions-layer');
      layer.innerHTML = '';

      // Show last few decisions as badges on nodes
      const recentDecisions = simState.decisions.slice(-20);
      const agentDecisionMap = {};

      for (const d of recentDecisions) {
        if (!agentDecisionMap[d.agentId]) agentDecisionMap[d.agentId] = [];
        agentDecisionMap[d.agentId].push(d);
      }

      for (const [agentId, decisions] of Object.entries(agentDecisionMap)) {
        const agent = simState.agents[agentId];
        if (!agent) continue;
        if (simState.activeFilters.size > 0 && !simState.activeFilters.has(agent.taskId)) continue;

        // Show the most recent decision as a badge
        const d = decisions[decisions.length - 1];
        const dt = DECISION_TYPES[d.type];
        if (!dt) continue;

        const bx = agent.x + agent.nodeSize * 0.85;
        const by = agent.y + agent.nodeSize * 0.3;

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('class', 'decision-badge');
        g.setAttribute('transform', `translate(${bx}, ${by})`);
        g.addEventListener('click', (e) => {
          e.stopPropagation();
          showDecisionPopover(d, e);
        });

        // Badge dot
        const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        dot.setAttribute('cx', 0);
        dot.setAttribute('cy', 0);
        dot.setAttribute('r', 5);
        dot.setAttribute('fill', dt.color);
        dot.setAttribute('stroke', '#0d1117');
        dot.setAttribute('stroke-width', '2');
        g.appendChild(dot);

        // Count if multiple
        if (decisions.length > 1) {
          const count = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          count.setAttribute('x', 8);
          count.setAttribute('y', 3);
          count.setAttribute('font-size', '8');
          count.setAttribute('font-family', 'var(--font-mono)');
          count.setAttribute('fill', dt.color);
          count.setAttribute('text-anchor', 'start');
          count.textContent = decisions.length.toString();
          g.appendChild(count);
        }

        layer.appendChild(g);
      }
    }

    // ========================================
    // TOOLTIP
    // ========================================
    function showTooltip(agentId, event) {
      const agent = simState.agents[agentId];
      if (!agent) return;
      const tooltip = document.getElementById('tooltip');
      const typeInfo = AGENT_TYPES[agent.type];

      document.getElementById('tooltip-name').textContent = agent.name;
      document.getElementById('tooltip-meta').innerHTML = `${typeInfo.label} &middot; ${agent.taskName} &middot; <span style="color:${STATUS_COLORS[agent.status]}">${agent.status}</span>`;
      document.getElementById('tooltip-tokens').textContent = formatNumber(agent.tokens);
      document.getElementById('tooltip-progress').textContent = Math.round(agent.progress) + '%';

      tooltip.style.display = 'block';
      tooltip.style.left = (event.clientX + 14) + 'px';
      tooltip.style.top = (event.clientY - 10) + 'px';
    }

    function hideTooltip() {
      document.getElementById('tooltip').style.display = 'none';
    }

    // ========================================
    // SELECT / DESELECT AGENT
    // ========================================
    function selectAgent(id) {
      simState.selectedAgent = id;
      document.getElementById('panel-empty').style.display = 'none';
      document.getElementById('panel-content').style.display = 'flex';
      updateDetailPanel();
    }

    function deselectAgent() {
      simState.selectedAgent = null;
      document.getElementById('panel-empty').style.display = 'flex';
      document.getElementById('panel-content').style.display = 'none';
    }

    function updateDetailPanel() {
      const id = simState.selectedAgent;
      if (!id) return;
      const agent = simState.agents[id];
      if (!agent) return;
      const typeInfo = AGENT_TYPES[agent.type];
      const statusColor = STATUS_COLORS[agent.status];

      // Header
      document.getElementById('panel-header').innerHTML = `
        <div class="panel-agent-icon" style="background:${typeInfo.color}">${typeInfo.symbol}</div>
        <div class="panel-agent-info">
          <div class="panel-agent-name">${agent.name}</div>
          <div class="panel-agent-meta">
            <span class="panel-agent-type">${typeInfo.label}</span>
            <span style="color:var(--fg-subtle)">&middot;</span>
            <span class="status-badge ${agent.status}">
              <span class="dot"></span>
              ${agent.status}
            </span>
          </div>
        </div>
        <button class="panel-close" onclick="deselectAgent()">&times;</button>
      `;

      updateDetailsTab(agent, typeInfo, statusColor);
      updateDecisionsTab(agent);
      updateActivityTab(agent);
    }

    function updateDetailsTab(agent, typeInfo, statusColor) {
      const task = TASKS.find(t => t.id === agent.taskId);

      // Find parents and children
      const parents = [];
      const children = [];
      if (task) {
        for (const a of task.agents) {
          if (a.children.includes(agent.id)) parents.push(a);
          if (agent.children.includes(a.id)) children.push(a);
        }
      }

      let html = `
        <div class="panel-section">
          <div class="panel-section-title">Task</div>
          <div style="font-size:13px;font-weight:500;margin-bottom:4px">${agent.taskName}</div>
          <div style="font-size:11px;color:var(--fg-subtle)">Depth ${agent.depth} &middot; Ring ${agent.depth}</div>
        </div>
        <div class="panel-section">
          <div class="panel-section-title">Progress</div>
          <div style="display:flex;justify-content:space-between;margin-bottom:4px">
            <span style="font-size:12px;color:var(--fg-muted)">Completion</span>
            <span style="font-size:12px;font-family:var(--font-mono);font-weight:500">${Math.round(agent.progress)}%</span>
          </div>
          <div class="progress-bar-container">
            <div class="progress-bar-fill" style="width:${agent.progress}%;background:${statusColor}"></div>
          </div>
        </div>
        <div class="panel-section">
          <div class="panel-section-title">Metrics</div>
          <div class="stat-grid">
            <div class="stat-item">
              <div class="stat-label">Tokens</div>
              <div class="stat-value">${formatNumber(agent.tokens)}</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Cost</div>
              <div class="stat-value cost">$${agent.cost.toFixed(3)}</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Messages</div>
              <div class="stat-value">${agent.messages}</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Turns</div>
              <div class="stat-value">${agent.turns}</div>
            </div>
          </div>
        </div>
      `;

      // Relationships
      if (parents.length > 0 || children.length > 0) {
        html += `<div class="panel-section"><div class="panel-section-title">Relationships</div>`;
        for (const p of parents) {
          const pState = simState.agents[p.id];
          const pType = AGENT_TYPES[p.type];
          html += `
            <div class="relationship-item" style="cursor:pointer" onclick="selectAgent('${p.id}')">
              <span class="relationship-arrow">&larr;</span>
              <div class="relationship-dot" style="background:${pType.color}"></div>
              <span class="relationship-name">${p.name}</span>
              <span class="relationship-status" style="color:${STATUS_COLORS[pState.status]}">${pState.status}</span>
            </div>`;
        }
        for (const c of children) {
          const cState = simState.agents[c.id];
          const cType = AGENT_TYPES[c.type];
          html += `
            <div class="relationship-item" style="cursor:pointer" onclick="selectAgent('${cState.id}')">
              <span class="relationship-arrow">&rarr;</span>
              <div class="relationship-dot" style="background:${cType.color}"></div>
              <span class="relationship-name">${c.name}</span>
              <span class="relationship-status" style="color:${STATUS_COLORS[cState.status]}">${cState.status}</span>
            </div>`;
        }
        html += `</div>`;
      }

      document.getElementById('tab-details').innerHTML = html;
    }

    function updateDecisionsTab(agent) {
      const agentDecisions = agent.decisions || [];
      if (agentDecisions.length === 0) {
        document.getElementById('tab-decisions').innerHTML = `
          <div class="panel-section">
            <div style="text-align:center;color:var(--fg-subtle);padding:32px 0">
              No decisions recorded yet
            </div>
          </div>`;
        return;
      }

      let html = `<div class="panel-section">
        <div class="panel-section-title">Recent Decisions (${agentDecisions.length})</div>
        ${agentDecisions.slice(-10).reverse().map((d, i) => {
          const dt = DECISION_TYPES[d.type];
          return `
            <div class="decision-feed-item" onclick="showDecisionPopover(window._decisions[${simState.decisions.indexOf(d)}], event)">
              <div class="decision-feed-icon" style="background:${dt.color}22;color:${dt.color}">${dt.icon}</div>
              <div class="decision-feed-content">
                <div class="decision-feed-type" style="color:${dt.color}">${dt.label}</div>
                <div class="decision-feed-summary">${d.summary}</div>
              </div>
              <div class="decision-feed-time">${d.time}</div>
            </div>`;
        }).join('')}
      </div>`;

      document.getElementById('tab-decisions').innerHTML = html;
    }

    function updateActivityTab(agent) {
      const activities = generateActivityLog(agent);

      document.getElementById('tab-activity').innerHTML = `
        <div class="panel-section">
          <div class="panel-section-title">Activity Log</div>
          ${activities.map(a => `
            <div class="activity-item">
              <span class="activity-time">${a.time}</span>
              <span class="activity-text">${a.text}</span>
            </div>
          `).join('')}
        </div>`;
    }

    function generateActivityLog(agent) {
      const logs = [];
      if (agent.status !== 'queued') {
        logs.push({ time: '0:00', text: `<strong>Started</strong> - Agent initialized on ring ${agent.depth}` });
      }
      if (agent.progress > 10) {
        logs.push({ time: '0:12', text: `Scanning workspace files` });
      }
      if (agent.progress > 25) {
        logs.push({ time: '0:28', text: `<strong>Planning</strong> - Analyzing dependencies` });
      }
      if (agent.progress > 40) {
        logs.push({ time: '1:05', text: `Writing code in <strong>${agent.name.split(' ')[0].toLowerCase()}</strong> module` });
      }
      if (agent.progress > 55) {
        logs.push({ time: '1:42', text: `Invoking <strong>Bash</strong> tool for test execution` });
      }
      if (agent.progress > 70) {
        logs.push({ time: '2:20', text: `Running <strong>tests</strong> - 14/16 passing` });
      }
      if (agent.progress > 85) {
        logs.push({ time: '3:10', text: `Code review cycle completed` });
      }
      if (agent.status === 'completed') {
        logs.push({ time: '3:55', text: `<strong>Completed</strong> - All checks passed` });
      }
      if (agent.status === 'failed') {
        logs.push({ time: '2:45', text: `<strong>Failed</strong> - Build error in test suite` });
      }
      if (agent.status === 'blocked') {
        logs.push({ time: '1:30', text: `<strong>Blocked</strong> - Waiting on dependency` });
      }
      return logs.reverse();
    }

    // ========================================
    // DECISION POPOVER
    // ========================================
    window._decisions = [];

    function showDecisionPopover(decision, event) {
      if (!decision) return;
      const dt = DECISION_TYPES[decision.type];
      const agent = simState.agents[decision.agentId];
      const container = document.getElementById('popover-container');

      const confColor = decision.confidence >= 85 ? '#34D399' : decision.confidence >= 60 ? '#FFD866' : '#F87171';

      container.innerHTML = `
        <div class="popover-overlay" onclick="closePopover()"></div>
        <div class="decision-popover" style="left:${Math.min(event.clientX + 10, window.innerWidth - 360)}px;top:${Math.min(event.clientY - 20, window.innerHeight - 400)}px">
          <div class="popover-header">
            <div class="popover-icon" style="background:${dt.color}22;color:${dt.color}">${dt.icon}</div>
            <div>
              <div class="popover-title">${dt.label}</div>
              <div class="popover-subtitle">${agent ? agent.name : 'Unknown'} &middot; ${decision.time}</div>
            </div>
          </div>
          <div class="popover-body">
            <div class="popover-section">
              <div class="popover-label">Summary</div>
              <div class="popover-text">${decision.summary}</div>
            </div>
            <div class="popover-section">
              <div class="popover-label">Detail</div>
              <div class="popover-text">${decision.detail}</div>
            </div>
            <div class="popover-section">
              <div class="popover-label">Confidence</div>
              <div class="confidence-value" style="color:${confColor}">${decision.confidence}%</div>
              <div class="confidence-bar-bg">
                <div class="confidence-bar-fill" style="width:${decision.confidence}%;background:${confColor}"></div>
              </div>
              <div class="confidence-markers">
                <span>0</span>
                <span style="color:${decision.confidence >= 60 ? '#FFD866' : 'var(--fg-subtle)'}">60</span>
                <span style="color:${decision.confidence >= 85 ? '#34D399' : 'var(--fg-subtle)'}">85</span>
                <span>100</span>
              </div>
            </div>
            <div class="popover-section">
              <div class="popover-label">Criteria</div>
              <div class="popover-tag-list">
                ${decision.criteria.map(c => `<span class="popover-tag">${c}</span>`).join('')}
              </div>
            </div>
            <div class="popover-section">
              <div class="popover-label">Alternatives</div>
              ${decision.alternatives.map(a => `
                <div class="popover-alternative">
                  <span class="popover-alternative-name">${a.name}</span>
                  <span class="popover-alternative-score">${a.score}%</span>
                </div>
              `).join('')}
            </div>
          </div>
          <div class="popover-footer">
            <span class="popover-policy">${decision.policy}</span>
            <button class="override-btn" onclick="closePopover()">Override</button>
          </div>
        </div>`;
    }

    function closePopover() {
      document.getElementById('popover-container').innerHTML = '';
    }

    // ========================================
    // PAN & ZOOM
    // ========================================
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let panOffset = { x: 0, y: 0 };
    let zoomLevel = 1;

    function updateTransform() {
      const g = document.getElementById('transform-group');
      g.setAttribute('transform', `translate(${panOffset.x}, ${panOffset.y}) scale(${zoomLevel})`);
      document.getElementById('zoom-label').textContent = Math.round(zoomLevel * 100) + '%';
    }

    const svgEl = document.getElementById('orbit-svg');

    svgEl.addEventListener('mousedown', (e) => {
      if (e.target === svgEl || e.target.closest('#orbit-rings-layer') || e.target.closest('#arcs-layer')) {
        isDragging = true;
        dragStart = { x: e.clientX - panOffset.x, y: e.clientY - panOffset.y };
        svgEl.classList.add('dragging');
      }
    });

    window.addEventListener('mousemove', (e) => {
      if (isDragging) {
        panOffset.x = e.clientX - dragStart.x;
        panOffset.y = e.clientY - dragStart.y;
        updateTransform();
      }
    });

    window.addEventListener('mouseup', () => {
      isDragging = false;
      svgEl.classList.remove('dragging');
    });

    svgEl.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.92 : 1.08;
      const newZoom = Math.max(0.2, Math.min(4, zoomLevel * delta));

      // Zoom toward mouse position
      const rect = svgEl.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      panOffset.x = mx - (mx - panOffset.x) * (newZoom / zoomLevel);
      panOffset.y = my - (my - panOffset.y) * (newZoom / zoomLevel);
      zoomLevel = newZoom;
      updateTransform();
    }, { passive: false });

    svgEl.addEventListener('click', (e) => {
      if (e.target === svgEl || e.target.closest('#orbit-rings-layer')) {
        deselectAgent();
      }
    });

    document.getElementById('zoom-in').addEventListener('click', () => {
      zoomLevel = Math.min(4, zoomLevel * 1.2);
      updateTransform();
    });

    document.getElementById('zoom-out').addEventListener('click', () => {
      zoomLevel = Math.max(0.2, zoomLevel * 0.8);
      updateTransform();
    });

    document.getElementById('zoom-fit').addEventListener('click', () => {
      zoomLevel = 1;
      panOffset = { x: 0, y: 0 };
      updateTransform();
    });

    document.getElementById('toggle-labels').addEventListener('click', function() {
      simState.showLabels = !simState.showLabels;
      this.classList.toggle('active', simState.showLabels);
    });

    // ========================================
    // TASK FILTER CHIPS
    // ========================================
    function buildFilterChips() {
      const container = document.getElementById('task-filters');
      container.innerHTML = '';

      const allChip = document.createElement('button');
      allChip.className = `task-filter-chip ${simState.activeFilters.size === 0 ? 'active' : ''}`;
      allChip.innerHTML = `All <span class="count">${Object.keys(simState.agents).length}</span>`;
      allChip.onclick = () => {
        simState.activeFilters.clear();
        buildFilterChips();
      };
      container.appendChild(allChip);

      for (const task of TASKS) {
        const chip = document.createElement('button');
        chip.className = `task-filter-chip ${simState.activeFilters.has(task.id) ? 'active' : ''}`;
        chip.innerHTML = `${task.name.split(' ').slice(0, 2).join(' ')} <span class="count">${task.agents.length}</span>`;
        chip.onclick = () => {
          if (simState.activeFilters.has(task.id)) {
            simState.activeFilters.delete(task.id);
          } else {
            simState.activeFilters.add(task.id);
          }
          buildFilterChips();
        };
        container.appendChild(chip);
      }
    }

    // ========================================
    // PANEL TAB SWITCHING
    // ========================================
    document.querySelectorAll('.panel-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.panel-tab-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`tab-${tab.dataset.tab}`).classList.add('active');
      });
    });

    // ========================================
    // SIMULATION ENGINE
    // ========================================
    const DECISION_SUMMARIES = {
      auto_verify: [
        'All tests passing, auto-approving changes',
        'Code coverage above threshold, verification passed',
        'Lint and type checks clean, auto-verified'
      ],
      route: [
        'Routing to specialized coder for database module',
        'Delegating UI components to frontend specialist',
        'Assigning infrastructure task to DevOps agent'
      ],
      retry: [
        'Test flake detected, retrying with fresh context',
        'Build timeout, retrying with extended limits',
        'Network error during API call, attempting retry'
      ],
      escalate: [
        'Critical security finding requires human review',
        'Breaking change detected, escalating to architect',
        'Resource limit exceeded, needs manual intervention'
      ],
      spawn: [
        'Spawning parallel workers for batch processing',
        'Creating sub-agent for isolated module testing',
        'Forking agent for concurrent API development'
      ],
      tool_select: [
        'Selected grep for codebase search over AST',
        'Choosing TypeScript compiler API for type analysis',
        'Using Docker SDK for container management'
      ],
      delegate: [
        'Delegating review to specialized reviewer agent',
        'Passing security scan to dedicated scanner',
        'Handing off deployment to deployer agent'
      ],
      throttle: [
        'Reducing concurrency due to rate limits',
        'Throttling API calls to respect quotas',
        'Slowing batch size for memory management'
      ],
      prioritize: [
        'Prioritizing critical path tasks first',
        'Reordering queue by dependency depth',
        'Moving blocking task to front of queue'
      ]
    };

    const DECISION_DETAILS = {
      auto_verify: 'Automated verification passed all 47 checks including unit tests, integration tests, and static analysis. No manual review required based on policy thresholds.',
      route: 'Analysis of task requirements determined specialized handling needed. Routing based on agent capability matching and current workload distribution.',
      retry: 'Transient failure detected. Previous attempt showed intermittent behavior consistent with a flaky dependency. Retrying with incremental backoff strategy.',
      escalate: 'Issue severity exceeds automated handling threshold. Human oversight required per security policy before proceeding with changes.',
      spawn: 'Workload analysis indicates parallel execution would reduce completion time by approximately 60%. Spawning workers with isolated contexts.',
      tool_select: 'Evaluated available tools against task requirements. Selected tool provides best accuracy for current file types and analysis depth needed.',
      delegate: 'Current agent lacks specialized capability for this sub-task. Delegation to expert agent improves quality and reduces iteration cycles.',
      throttle: 'External API rate limit approaching threshold. Proactively reducing request frequency to avoid hard blocks and maintain steady progress.',
      prioritize: 'Dependency analysis revealed critical path optimization opportunity. Reordering execution queue to minimize overall completion time.'
    };

    function generateDecision(agentId) {
      const types = Object.keys(DECISION_TYPES);
      const type = types[Math.floor(Math.random() * types.length)];
      const summaries = DECISION_SUMMARIES[type];
      const summary = summaries[Math.floor(Math.random() * summaries.length)];

      const minutes = Math.floor(simState.tick / 60);
      const seconds = Math.floor(simState.tick % 60);
      const time = `${minutes}:${seconds.toString().padStart(2, '0')}`;

      const decision = {
        type,
        agentId,
        summary,
        detail: DECISION_DETAILS[type],
        confidence: 55 + Math.floor(Math.random() * 40),
        time,
        criteria: ['latency', 'accuracy', 'cost', 'coverage', 'reliability', 'throughput'].sort(() => Math.random() - 0.5).slice(0, 2 + Math.floor(Math.random() * 2)),
        alternatives: [
          { name: 'Alternative A', score: 30 + Math.floor(Math.random() * 40) },
          { name: 'Alternative B', score: 20 + Math.floor(Math.random() * 30) }
        ],
        policy: 'auto-' + ['verify', 'route', 'delegate'][Math.floor(Math.random() * 3)] + '-v2.1'
      };

      simState.decisions.push(decision);
      window._decisions = simState.decisions;

      const agent = simState.agents[agentId];
      if (agent) agent.decisions.push(decision);

      return decision;
    }

    function isRoot(agentId) {
      const agent = simState.agents[agentId];
      if (!agent) return false;
      const task = TASKS.find(t => t.id === agent.taskId);
      if (!task) return false;
      return !task.agents.some(a => a.children.includes(agentId));
    }

    function canStart(agentId) {
      const agent = simState.agents[agentId];
      if (!agent) return false;
      const task = TASKS.find(t => t.id === agent.taskId);
      if (!task) return false;

      for (const other of task.agents) {
        if (other.children.includes(agentId)) {
          const parentState = simState.agents[other.id];
          if (parentState.status !== 'completed') return false;
        }
      }
      return true;
    }

    function simulationTick() {
      if (!simState.running) return;

      simState.tick += simState.speed;

      for (const id of Object.keys(simState.agents)) {
        const agent = simState.agents[id];

        switch (agent.status) {
          case 'queued':
            if (isRoot(id)) {
              if (simState.tick > 5 + Math.random() * 25) {
                agent.status = 'running';
                agent.startedAt = simState.tick;
              }
            } else if (canStart(id)) {
              agent.status = 'running';
              agent.startedAt = simState.tick;
            }
            break;

          case 'running':
            const speed = (0.15 + Math.random() * 0.45) * simState.speed;
            agent.progress = Math.min(100, agent.progress + speed);
            agent.tokens += Math.floor(agent.tokenRate * speed * 0.02);
            agent.cost = agent.tokens * 0.000003;
            agent.messages += Math.random() < 0.05 * simState.speed ? 1 : 0;
            agent.turns += Math.random() < 0.02 * simState.speed ? 1 : 0;

            if (Math.random() < 0.004 * simState.speed) {
              generateDecision(id);
            }

            if (agent.progress >= 100) {
              agent.progress = 100;
              agent.status = 'verifying';
              agent.verificationScore = 0;
            }

            if (Math.random() < 0.0004 * simState.speed && agent.progress > 30 && agent.progress < 90) {
              agent.status = 'failed';
              generateDecision(id);
            }

            if (Math.random() < 0.0003 * simState.speed && agent.progress > 20 && agent.progress < 70) {
              agent.status = 'blocked';
            }
            break;

          case 'verifying':
            agent.verificationScore += (0.5 + Math.random() * 1) * simState.speed;
            if (agent.verificationScore >= 100) {
              agent.verificationScore = 100;
              agent.verified = true;
              agent.status = 'completed';
              if (Math.random() < 0.5) generateDecision(id);
            }
            break;

          case 'blocked':
            if (Math.random() < 0.01 * simState.speed) {
              agent.status = 'running';
              generateDecision(id);
            }
            break;

          case 'failed':
            if (Math.random() < 0.005 * simState.speed) {
              agent.status = 'running';
              agent.progress = Math.max(0, agent.progress - 20);
              generateDecision(id);
            }
            break;

          case 'completed':
            break;
        }
      }

      updateMetrics();
    }

    function updateMetrics() {
      const agents = Object.values(simState.agents);
      const active = agents.filter(a => a.status === 'running' || a.status === 'verifying').length;
      const total = agents.length;
      const tokens = agents.reduce((sum, a) => sum + a.tokens, 0);
      const cost = agents.reduce((sum, a) => sum + a.cost, 0);

      document.getElementById('metric-active').textContent = active;
      document.getElementById('metric-total').textContent = total;
      document.getElementById('metric-tokens').textContent = formatNumber(tokens);
      document.getElementById('metric-cost').textContent = '$' + cost.toFixed(2);
      document.getElementById('metric-decisions').textContent = simState.decisions.length;
    }

    function formatNumber(n) {
      if (n >= 1000000) return (n / 1000000).toFixed(1) + 'M';
      if (n >= 1000) return (n / 1000).toFixed(1) + 'K';
      return n.toString();
    }

    // ========================================
    // RENDER LOOP
    // ========================================
    let lastRenderTime = 0;
    const RENDER_INTERVAL = 40; // ~25fps

    function renderLoop(timestamp) {
      if (timestamp - lastRenderTime >= RENDER_INTERVAL) {
        simulationTick();
        updateOrbits();

        renderOrbitRings();
        renderArcs();
        renderParticles();
        renderNodes();
        renderLabels();
        renderDecisions();

        if (simState.selectedAgent) {
          updateDetailPanel();
        }

        lastRenderTime = timestamp;
      }

      requestAnimationFrame(renderLoop);
    }

    // ========================================
    // CONTROLS
    // ========================================
    document.getElementById('sim-play').addEventListener('click', function() {
      simState.running = !simState.running;
      this.innerHTML = simState.running ? '&#9654;' : '&#9646;&#9646;';
      this.classList.toggle('active', simState.running);
    });

    // Speed buttons
    document.querySelectorAll('.speed-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        simState.speed = parseInt(this.dataset.speed);
      });
    });

    document.getElementById('sim-reset').addEventListener('click', function() {
      simState.tick = 0;
      simState.decisions = [];
      window._decisions = [];
      simState.selectedAgent = null;

      for (const id of Object.keys(simState.agents)) {
        const agent = simState.agents[id];
        agent.status = 'queued';
        agent.progress = 0;
        agent.tokens = 0;
        agent.cost = 0;
        agent.messages = 0;
        agent.turns = 0;
        agent.startedAt = null;
        agent.decisions = [];
        agent.verified = false;
        agent.verificationScore = 0;
        agent.orbitAngle = agent.baseAngle;
      }

      deselectAgent();
      updateMetrics();
    });

    // ========================================
    // INITIALIZATION
    // ========================================
    function init() {
      initAgentStates();
      computeClusterLayout();
      buildFilterChips();
      updateTransform();
      requestAnimationFrame(renderLoop);

      window.addEventListener('resize', () => {
        computeClusterLayout();
        buildFilterChips();
      });
    }

    init();
  </script>
</body>
</html>
