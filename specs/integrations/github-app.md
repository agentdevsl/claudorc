# GitHub App Integration Specification

## Overview

AgentPane integrates with GitHub via a GitHub App to enable repository access, configuration sync, webhook events, and PR management. This specification defines the complete GitHub integration, from OAuth authorization through webhook handling.

**Wireframe References**:
- [github-app-setup.html](../wireframes/github-app-setup.html) - **Primary**: Global GitHub App setup flow (OAuth, installations, permissions, management)
- [github-project-picker.html](../wireframes/github-project-picker.html) - Project selection with GitHub repos
- [github-multi-project-dashboard.html](../wireframes/github-multi-project-dashboard.html) - Multi-project dashboard view

---

## Architecture

### Integration Components

```text
┌─────────────────────────────────────────────────────────────────────────┐
│                           AgentPane Client                              │
│  ┌────────────────┐  ┌────────────────┐  ┌────────────────────────┐    │
│  │ Project Picker │  │  Config Sync   │  │    PR Management       │    │
│  │  (OAuth Flow)  │  │ (.agentpane/)  │  │ (Create/Merge PRs)     │    │
│  └────────┬───────┘  └────────┬───────┘  └───────────┬────────────┘    │
└───────────┼───────────────────┼──────────────────────┼─────────────────┘
            │                   │                      │
            ▼                   ▼                      ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                          AgentPane Server                               │
│  ┌────────────────┐  ┌────────────────┐  ┌────────────────────────┐    │
│  │  OAuth Handler │  │ GitHub Service │  │   Webhook Handler      │    │
│  │ /api/github/*  │  │   (Octokit)    │  │  /api/webhooks/github  │    │
│  └────────┬───────┘  └────────┬───────┘  └───────────┬────────────┘    │
│           │                   │                      │                  │
│           └───────────────────┼──────────────────────┘                  │
│                               │                                         │
│                      ┌────────▼────────┐                               │
│                      │    PGlite DB    │                               │
│                      │  (Installations,│                               │
│                      │   RepoConfigs)  │                               │
│                      └─────────────────┘                               │
└─────────────────────────────────────────────────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                          GitHub API                                     │
│  ┌────────────────┐  ┌────────────────┐  ┌────────────────────────┐    │
│  │   OAuth API    │  │   REST API     │  │     Webhooks           │    │
│  │ (User Auth)    │  │ (Repos, PRs)   │  │ (Push, PR, Issues)     │    │
│  └────────────────┘  └────────────────┘  └────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## GitHub App Configuration

### App Settings

```yaml
# GitHub App manifest
name: AgentPane
url: https://agentpane.dev
description: Multi-agent task management for code repositories

# Permissions (Repository)
permissions:
  contents: write        # Read/write repo contents
  pull_requests: write   # Create and manage PRs
  issues: write          # Create and manage issues
  metadata: read         # Basic repo metadata

# Webhook events
webhook_events:
  - push
  - pull_request
  - issues
  - installation
  - installation_repositories

# OAuth settings
callback_url: http://localhost:5173/api/github/callback
setup_url: http://localhost:5173/api/github/setup
```

### Environment Variables

```bash
# .env
GITHUB_APP_ID=123456
GITHUB_APP_NAME=agentpane
GITHUB_CLIENT_ID=Iv1.abc123def456
GITHUB_CLIENT_SECRET=secret_abc123def456
GITHUB_PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----"
GITHUB_WEBHOOK_SECRET=whsec_abc123def456
```

---

## Automated Installation Flow

### Overview

AgentPane uses the **GitHub App installation flow** (not OAuth) for a fully automated setup:

1. User clicks "Install GitHub App" → Redirects to GitHub
2. GitHub handles authorization and repository selection
3. Webhook delivers `installation` event with all details
4. App automatically syncs installations and repositories via Octokit

**Benefits of App Installation vs OAuth:**
- No user tokens to manage or refresh
- Installation tokens auto-generated by Octokit
- Webhook-driven state management (no polling)
- Per-repository permissions (not user-wide)

### Installation URL Generator

```typescript
// lib/github/installation.ts
import { App } from 'octokit';
import { createAppAuth } from '@octokit/auth-app';

const GITHUB_APP_NAME = process.env.GITHUB_APP_NAME!;
const GITHUB_APP_ID = process.env.GITHUB_APP_ID!;
const GITHUB_PRIVATE_KEY = process.env.GITHUB_PRIVATE_KEY!;

// Create the GitHub App instance (singleton)
export const githubApp = new App({
  appId: GITHUB_APP_ID,
  privateKey: GITHUB_PRIVATE_KEY,
  webhooks: {
    secret: process.env.GITHUB_WEBHOOK_SECRET!,
  },
});

// Generate installation URL - user clicks this to install
export function getInstallationUrl(state?: string): string {
  const baseUrl = `https://github.com/apps/${GITHUB_APP_NAME}/installations/new`;

  if (state) {
    // State parameter for tracking installation origin
    return `${baseUrl}?state=${encodeURIComponent(state)}`;
  }

  return baseUrl;
}

// Generate URL to modify existing installation
export function getInstallationSettingsUrl(installationId: number): string {
  return `https://github.com/settings/installations/${installationId}`;
}

// Generate URL for organization installation management
export function getOrgInstallationUrl(org: string): string {
  return `https://github.com/organizations/${org}/settings/installations`;
}
```

### Octokit App Class Usage

```typescript
// lib/github/client.ts
import { App, Octokit } from 'octokit';
import { createAppAuth } from '@octokit/auth-app';

// Singleton App instance for installation management
let _app: App | null = null;

export function getGitHubApp(): App {
  if (!_app) {
    _app = new App({
      appId: process.env.GITHUB_APP_ID!,
      privateKey: process.env.GITHUB_PRIVATE_KEY!,
      webhooks: {
        secret: process.env.GITHUB_WEBHOOK_SECRET!,
      },
    });
  }
  return _app;
}

// Get Octokit instance for a specific installation
// Octokit automatically handles token generation and refresh
export async function getInstallationOctokit(installationId: number): Promise<Octokit> {
  const app = getGitHubApp();
  return app.getInstallationOctokit(installationId);
}

// List all installations for this App (automated discovery)
export async function discoverInstallations() {
  const app = getGitHubApp();
  const installations: Installation[] = [];

  // Octokit handles pagination automatically
  for await (const { installation } of app.eachInstallation.iterator()) {
    installations.push({
      id: installation.id,
      account: installation.account,
      permissions: installation.permissions,
      repositorySelection: installation.repository_selection,
      createdAt: installation.created_at,
    });
  }

  return installations;
}

// Iterate over all repositories across all installations
export async function* iterateAllRepositories() {
  const app = getGitHubApp();

  for await (const { octokit, repository } of app.eachRepository.iterator()) {
    yield { octokit, repository };
  }
}
```

### Setup Callback Handler

```typescript
// app/routes/api/github/setup.ts
import { createServerFileRoute } from '@tanstack/react-start/server';
import { getGitHubApp, getInstallationOctokit } from '@/lib/github/client';
import { saveInstallation, syncInstallationRepos } from '@/lib/github/installations';

// GitHub redirects here after App installation
export const ServerRoute = createServerFileRoute().methods({
  GET: async ({ request }) => {
    const url = new URL(request.url);
    const installationId = url.searchParams.get('installation_id');
    const setupAction = url.searchParams.get('setup_action'); // 'install' | 'update'
    const state = url.searchParams.get('state');

    if (!installationId) {
      return Response.redirect('/settings/github?error=missing_installation', 302);
    }

    const installationIdNum = parseInt(installationId, 10);

    try {
      // Get installation details using Octokit
      const octokit = await getInstallationOctokit(installationIdNum);

      // Fetch installation metadata
      const { data: installation } = await octokit.rest.apps.getInstallation({
        installation_id: installationIdNum,
      });

      // Save to database
      await saveInstallation({
        id: installationIdNum,
        account: installation.account!,
        permissions: installation.permissions,
        repositorySelection: installation.repository_selection,
      });

      // Sync accessible repositories
      await syncInstallationRepos(installationIdNum);

      // Redirect to success page
      return Response.redirect('/settings/github?success=installed', 302);
    } catch (error) {
      console.error('Setup callback error:', error);
      return Response.redirect('/settings/github?error=setup_failed', 302);
    }
  },
});
```

### Automated Repository Sync

```typescript
// lib/github/installations.ts
import { getInstallationOctokit, getGitHubApp } from './client';
import { db } from '@/db/client';
import { githubInstallations, repositoryConfigs } from '@/db/schema';
import { eq } from 'drizzle-orm';

// Sync all repositories for an installation (called on setup and via webhook)
export async function syncInstallationRepos(installationId: number): Promise<void> {
  const octokit = await getInstallationOctokit(installationId);

  // Octokit handles pagination automatically
  const repos = await octokit.paginate(
    octokit.rest.apps.listReposAccessibleToInstallation,
    { per_page: 100 }
  );

  for (const repo of repos) {
    // Check for .agentpane config
    const hasConfig = await checkConfigExists(octokit, repo.owner.login, repo.name);

    // Upsert repository config
    await db.insert(repositoryConfigs).values({
      installationId: String(installationId),
      owner: repo.owner.login,
      repo: repo.name,
      fullName: repo.full_name,
      defaultBranch: repo.default_branch,
      isPrivate: repo.private,
      lastSyncedAt: hasConfig ? new Date() : null,
    }).onConflictDoUpdate({
      target: [repositoryConfigs.owner, repositoryConfigs.repo],
      set: {
        installationId: String(installationId),
        defaultBranch: repo.default_branch,
        isPrivate: repo.private,
        updatedAt: new Date(),
      },
    });

    // If config exists, sync it
    if (hasConfig) {
      await syncConfig(installationId, repo.owner.login, repo.name);
    }
  }
}

// Check if .agentpane config exists
async function checkConfigExists(
  octokit: Octokit,
  owner: string,
  repo: string
): Promise<boolean> {
  try {
    await octokit.rest.repos.getContent({
      owner,
      repo,
      path: '.agentpane/config.json',
    });
    return true;
  } catch {
    return false;
  }
}
```

### Webhook-Driven Installation Management

```typescript
// lib/github/webhook-setup.ts
import { getGitHubApp } from './client';
import { saveInstallation, removeInstallation, syncInstallationRepos } from './installations';

// Register webhook handlers on App startup
export function setupWebhookHandlers() {
  const app = getGitHubApp();

  // Handle new installations automatically
  app.webhooks.on('installation.created', async ({ payload }) => {
    console.log(`[Auto] App installed for ${payload.installation.account.login}`);

    await saveInstallation({
      id: payload.installation.id,
      account: payload.installation.account,
      permissions: payload.installation.permissions,
      repositorySelection: payload.installation.repository_selection,
    });

    // Automatically sync all accessible repositories
    await syncInstallationRepos(payload.installation.id);
  });

  // Handle installation updates (repo access changes)
  app.webhooks.on('installation_repositories', async ({ payload }) => {
    console.log(`[Auto] Repo access changed for installation ${payload.installation.id}`);

    // Re-sync repositories
    await syncInstallationRepos(payload.installation.id);
  });

  // Handle uninstallation
  app.webhooks.on('installation.deleted', async ({ payload }) => {
    console.log(`[Auto] App uninstalled from ${payload.installation.account.login}`);
    await removeInstallation(String(payload.installation.id));
  });

  // Handle push events for config sync
  app.webhooks.on('push', async ({ payload, octokit }) => {
    // Check if .agentpane files changed
    const configChanged = payload.commits?.some((commit) =>
      [...(commit.added ?? []), ...(commit.modified ?? [])]
        .some((path) => path.startsWith('.agentpane/'))
    );

    if (configChanged) {
      console.log(`[Auto] Config changed in ${payload.repository.full_name}, syncing...`);
      await syncConfig(
        payload.installation!.id,
        payload.repository.owner.login,
        payload.repository.name
      );
    }
  });
}
```

### API Endpoints

```typescript
// app/routes/api/github/install.ts
import { createServerFileRoute } from '@tanstack/react-start/server';
import { getInstallationUrl } from '@/lib/github/installation';
import { createId } from '@paralleldrive/cuid2';

export const ServerRoute = createServerFileRoute().methods({
  // GET: Returns installation URL for client-side redirect
  GET: async () => {
    const state = createId(); // For tracking
    const installUrl = getInstallationUrl(state);

    return Response.json({
      ok: true,
      data: { url: installUrl, state }
    });
  },

  // POST: Redirect to installation (for form submission)
  POST: async () => {
    const state = createId();
    const installUrl = getInstallationUrl(state);

    return Response.redirect(installUrl, 302);
  },
});

// app/routes/api/github/installations.ts
import { createServerFileRoute } from '@tanstack/react-start/server';
import { discoverInstallations } from '@/lib/github/client';
import { db } from '@/db/client';
import { githubInstallations } from '@/db/schema';

export const ServerRoute = createServerFileRoute().methods({
  // GET: List all installations with their repositories
  GET: async () => {
    // Option 1: From database (faster, may be stale)
    const cached = await db.select().from(githubInstallations);

    // Option 2: Live from GitHub API (always current)
    // const live = await discoverInstallations();

    return Response.json({
      ok: true,
      data: cached.map(i => ({
        id: i.id,
        accountLogin: i.accountLogin,
        accountType: i.accountType,
        accountAvatarUrl: i.accountAvatarUrl,
        status: i.status,
        installedAt: i.installedAt,
      }))
    });
  },

  // DELETE: Unlink an installation (user must uninstall from GitHub)
  DELETE: async ({ request }) => {
    const { installationId } = await request.json();

    // Note: This only removes from our DB
    // User must uninstall from GitHub to fully remove
    await db.delete(githubInstallations).where(
      eq(githubInstallations.id, installationId)
    );

    return Response.json({ ok: true });
  },
});
```

---

## Installation Management

### App Installation Client

```typescript
// lib/github/client.ts
import { Octokit } from 'octokit';
import { createAppAuth } from '@octokit/auth-app';

// Create Octokit instance for GitHub App
export function createAppOctokit() {
  return new Octokit({
    authStrategy: createAppAuth,
    auth: {
      appId: process.env.GITHUB_APP_ID!,
      privateKey: process.env.GITHUB_PRIVATE_KEY!,
    },
  });
}

// Create Octokit instance for specific installation
export function createInstallationOctokit(installationId: number) {
  return new Octokit({
    authStrategy: createAppAuth,
    auth: {
      appId: process.env.GITHUB_APP_ID!,
      privateKey: process.env.GITHUB_PRIVATE_KEY!,
      installationId,
    },
  });
}

// Get installation access token
export async function getInstallationToken(installationId: number): Promise<string> {
  const appOctokit = createAppOctokit();

  const { data } = await appOctokit.rest.apps.createInstallationAccessToken({
    installation_id: installationId,
  });

  return data.token;
}
```

### Installation Service

```typescript
// lib/github/installations.ts
import { db } from '@/db/client';
import { githubInstallations, repositoryConfigs } from '@/db/schema';
import { eq } from 'drizzle-orm';
import { createAppOctokit, createInstallationOctokit } from './client';
import type { Result } from '@/lib/utils/result';
import { ok, err } from '@/lib/utils/result';
import { GitHubErrors } from '@/lib/errors/github-errors';

export interface Installation {
  id: string;
  accountLogin: string;
  accountType: string;
  accountAvatarUrl: string;
  repositories: Repository[];
}

export interface Repository {
  id: number;
  name: string;
  fullName: string;
  private: boolean;
  defaultBranch: string;
  hasConfig: boolean;
}

// List all installations for the authenticated user
export async function listInstallations(): Promise<Result<Installation[], GitHubError>> {
  try {
    const appOctokit = createAppOctokit();
    const { data } = await appOctokit.rest.apps.listInstallations();

    const installations: Installation[] = [];

    for (const installation of data) {
      const installationOctokit = createInstallationOctokit(installation.id);

      // Get repositories accessible to this installation
      const { data: repoData } = await installationOctokit.rest.apps.listReposAccessibleToInstallation();

      const repositories: Repository[] = await Promise.all(
        repoData.repositories.map(async (repo) => {
          // Check if .agentpane config exists
          const hasConfig = await checkConfigExists(installationOctokit, repo.owner.login, repo.name);

          return {
            id: repo.id,
            name: repo.name,
            fullName: repo.full_name,
            private: repo.private,
            defaultBranch: repo.default_branch,
            hasConfig,
          };
        })
      );

      installations.push({
        id: String(installation.id),
        accountLogin: installation.account?.login ?? 'unknown',
        accountType: installation.account?.type ?? 'User',
        accountAvatarUrl: installation.account?.avatar_url ?? '',
        repositories,
      });
    }

    return ok(installations);
  } catch (error) {
    return err(GitHubErrors.AUTH_FAILED(String(error)));
  }
}

// Check if .agentpane config directory exists
async function checkConfigExists(
  octokit: Octokit,
  owner: string,
  repo: string
): Promise<boolean> {
  try {
    await octokit.rest.repos.getContent({
      owner,
      repo,
      path: '.agentpane',
    });
    return true;
  } catch {
    return false;
  }
}

// Store installation in database
export async function saveInstallation(installation: GitHubInstallationPayload): Promise<void> {
  await db.insert(githubInstallations).values({
    id: String(installation.id),
    accountId: String(installation.account.id),
    accountLogin: installation.account.login,
    accountType: installation.account.type,
    accountAvatarUrl: installation.account.avatar_url,
    status: 'active',
    permissions: installation.permissions,
    repositorySelection: installation.repository_selection,
    installedAt: new Date(),
  }).onConflictDoUpdate({
    target: githubInstallations.id,
    set: {
      status: 'active',
      permissions: installation.permissions,
      repositorySelection: installation.repository_selection,
      updatedAt: new Date(),
    },
  });
}

// Remove installation from database
export async function removeInstallation(installationId: string): Promise<void> {
  await db.update(githubInstallations)
    .set({ status: 'deleted', updatedAt: new Date() })
    .where(eq(githubInstallations.id, installationId));
}
```

---

## Repository Access

### Repository Operations

```typescript
// lib/github/repos.ts
import { createInstallationOctokit } from './client';
import type { Result } from '@/lib/utils/result';
import { ok, err } from '@/lib/utils/result';
import { GitHubErrors } from '@/lib/errors/github-errors';

// List repositories for an installation
export async function listRepositories(installationId: number): Promise<Result<Repository[], GitHubError>> {
  try {
    const octokit = createInstallationOctokit(installationId);
    const { data } = await octokit.rest.apps.listReposAccessibleToInstallation({
      per_page: 100,
    });

    return ok(data.repositories.map(repo => ({
      id: repo.id,
      name: repo.name,
      fullName: repo.full_name,
      owner: repo.owner.login,
      private: repo.private,
      defaultBranch: repo.default_branch,
      description: repo.description,
      language: repo.language,
      updatedAt: repo.updated_at,
    })));
  } catch (error: any) {
    if (error.status === 404) {
      return err(GitHubErrors.INSTALLATION_NOT_FOUND(String(installationId)));
    }
    return err(GitHubErrors.AUTH_FAILED(String(error)));
  }
}

// Get repository details
export async function getRepository(
  installationId: number,
  owner: string,
  repo: string
): Promise<Result<Repository, GitHubError>> {
  try {
    const octokit = createInstallationOctokit(installationId);
    const { data } = await octokit.rest.repos.get({ owner, repo });

    return ok({
      id: data.id,
      name: data.name,
      fullName: data.full_name,
      owner: data.owner.login,
      private: data.private,
      defaultBranch: data.default_branch,
      description: data.description,
      language: data.language,
      updatedAt: data.updated_at,
    });
  } catch (error: any) {
    if (error.status === 404) {
      return err(GitHubErrors.REPO_NOT_FOUND(owner, repo));
    }
    return err(GitHubErrors.AUTH_FAILED(String(error)));
  }
}

// Clone repository URL with installation token
export async function getCloneUrl(
  installationId: number,
  owner: string,
  repo: string
): Promise<Result<string, GitHubError>> {
  const token = await getInstallationToken(installationId);
  return ok(`https://x-access-token:${token}@github.com/${owner}/${repo}.git`);
}
```

---

## Configuration Sync

### Config File Structure

```text
.agentpane/
├── config.json          # Main configuration
├── prompts/
│   ├── system.md        # System prompt
│   └── task.md          # Task prompt template
└── tools.json           # Tool whitelist configuration
```

### Config Schema

```typescript
// lib/github/config-schema.ts
import { z } from 'zod';

export const agentConfigSchema = z.object({
  // Agent execution settings
  allowedTools: z.array(z.string()).default(['Read', 'Edit', 'Bash', 'Glob', 'Grep']),
  maxTurns: z.number().min(1).max(200).default(50),
  model: z.string().default('claude-sonnet-4-20250514'),

  // Project settings
  worktreeRoot: z.string().default('.worktrees'),
  initScript: z.string().optional(),
  envFile: z.string().optional(),
  defaultBranch: z.string().default('main'),

  // Concurrency
  maxConcurrentAgents: z.number().min(1).max(10).default(3),

  // Prompts (file references)
  prompts: z.object({
    system: z.string().optional(),  // Path to system prompt file
    task: z.string().optional(),    // Path to task prompt file
  }).optional(),
});

export type AgentConfig = z.infer<typeof agentConfigSchema>;
```

### Config Sync Service

```typescript
// lib/github/config-sync.ts
import { db } from '@/db/client';
import { repositoryConfigs, projects } from '@/db/schema';
import { eq, and } from 'drizzle-orm';
import { createInstallationOctokit } from './client';
import { agentConfigSchema, type AgentConfig } from './config-schema';
import type { Result } from '@/lib/utils/result';
import { ok, err } from '@/lib/utils/result';
import { GitHubErrors } from '@/lib/errors/github-errors';

// Fetch configuration from repository
export async function fetchConfig(
  installationId: number,
  owner: string,
  repo: string,
  configPath = '.agentpane/config.json',
  ref = 'main'
): Promise<Result<AgentConfig, GitHubError>> {
  try {
    const octokit = createInstallationOctokit(installationId);

    const { data } = await octokit.rest.repos.getContent({
      owner,
      repo,
      path: configPath,
      ref,
    });

    if (!('content' in data)) {
      return err(GitHubErrors.CONFIG_NOT_FOUND(configPath));
    }

    const content = Buffer.from(data.content, 'base64').toString('utf-8');
    const parsed = JSON.parse(content);
    const validated = agentConfigSchema.safeParse(parsed);

    if (!validated.success) {
      return err(GitHubErrors.CONFIG_INVALID(
        validated.error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
      ));
    }

    return ok(validated.data);
  } catch (error: any) {
    if (error.status === 404) {
      return err(GitHubErrors.CONFIG_NOT_FOUND(configPath));
    }
    return err(GitHubErrors.AUTH_FAILED(String(error)));
  }
}

// Fetch prompt file content
export async function fetchPromptFile(
  installationId: number,
  owner: string,
  repo: string,
  promptPath: string,
  ref = 'main'
): Promise<Result<string, GitHubError>> {
  try {
    const octokit = createInstallationOctokit(installationId);

    const { data } = await octokit.rest.repos.getContent({
      owner,
      repo,
      path: promptPath,
      ref,
    });

    if (!('content' in data)) {
      return err(GitHubErrors.CONFIG_NOT_FOUND(promptPath));
    }

    const content = Buffer.from(data.content, 'base64').toString('utf-8');
    return ok(content);
  } catch (error: any) {
    if (error.status === 404) {
      return err(GitHubErrors.CONFIG_NOT_FOUND(promptPath));
    }
    return err(GitHubErrors.AUTH_FAILED(String(error)));
  }
}

// Sync configuration from GitHub to database
export async function syncConfig(
  installationId: number,
  owner: string,
  repo: string
): Promise<Result<void, GitHubError>> {
  const configResult = await fetchConfig(installationId, owner, repo);

  if (!configResult.ok) {
    // Store sync error
    await db.update(repositoryConfigs)
      .set({
        syncError: configResult.error.message,
        updatedAt: new Date(),
      })
      .where(and(
        eq(repositoryConfigs.owner, owner),
        eq(repositoryConfigs.repo, repo)
      ));

    return configResult;
  }

  // Get current commit SHA
  const octokit = createInstallationOctokit(installationId);
  const { data: ref } = await octokit.rest.git.getRef({
    owner,
    repo,
    ref: 'heads/main',
  });

  // Update repository config
  await db.insert(repositoryConfigs).values({
    installationId: String(installationId),
    owner,
    repo,
    fullName: `${owner}/${repo}`,
    configPath: '.agentpane',
    configSha: ref.object.sha,
    config: configResult.value,
    lastSyncedAt: new Date(),
    syncError: null,
  }).onConflictDoUpdate({
    target: [repositoryConfigs.owner, repositoryConfigs.repo],
    set: {
      configSha: ref.object.sha,
      config: configResult.value,
      lastSyncedAt: new Date(),
      syncError: null,
      updatedAt: new Date(),
    },
  });

  // Update linked project if exists
  await db.update(projects)
    .set({
      config: configResult.value,
      updatedAt: new Date(),
    })
    .where(and(
      eq(projects.githubOwner, owner),
      eq(projects.githubRepo, repo)
    ));

  return ok(undefined);
}
```

---

## Webhook Handling

### Webhook Handler

```typescript
// app/routes/api/webhooks/github.ts
import { createServerFileRoute } from '@tanstack/react-start/server';
import { verifyWebhookSignature } from '@/lib/github/webhooks';
import { handlePushEvent, handlePREvent, handleInstallationEvent, handleIssuesEvent } from '@/lib/github/webhook-handlers';

export const ServerRoute = createServerFileRoute().methods({
  POST: async ({ request }) => {
    const signature = request.headers.get('x-hub-signature-256');
    const event = request.headers.get('x-github-event');
    const deliveryId = request.headers.get('x-github-delivery');

    if (!signature || !event) {
      return Response.json({ error: 'Missing headers' }, { status: 400 });
    }

    const body = await request.text();

    // Verify webhook signature
    const isValid = await verifyWebhookSignature(body, signature);
    if (!isValid) {
      return Response.json({ error: 'Invalid signature' }, { status: 401 });
    }

    const payload = JSON.parse(body);

    console.log(`[Webhook] Received ${event} event (delivery: ${deliveryId})`);

    try {
      switch (event) {
        case 'push':
          await handlePushEvent(payload);
          break;

        case 'pull_request':
          await handlePREvent(payload);
          break;

        case 'installation':
        case 'installation_repositories':
          await handleInstallationEvent(payload);
          break;

        case 'issues':
          await handleIssuesEvent(payload);
          break;

        default:
          console.log(`[Webhook] Unhandled event type: ${event}`);
      }

      return Response.json({ received: true });
    } catch (error) {
      console.error(`[Webhook] Error handling ${event}:`, error);
      return Response.json({ error: 'Handler error' }, { status: 500 });
    }
  },
});
```

### Webhook Signature Verification

```typescript
// lib/github/webhooks.ts
import { createHmac, timingSafeEqual } from 'crypto';

const WEBHOOK_SECRET = process.env.GITHUB_WEBHOOK_SECRET!;

export async function verifyWebhookSignature(
  payload: string,
  signature: string
): Promise<boolean> {
  const expected = `sha256=${createHmac('sha256', WEBHOOK_SECRET)
    .update(payload)
    .digest('hex')}`;

  const actual = Buffer.from(signature);
  const expectedBuffer = Buffer.from(expected);

  if (actual.length !== expectedBuffer.length) {
    return false;
  }

  return timingSafeEqual(actual, expectedBuffer);
}
```

### Webhook Event Handlers

```typescript
// lib/github/webhook-handlers.ts
import { syncConfig } from './config-sync';
import { saveInstallation, removeInstallation } from './installations';
import { db } from '@/db/client';
import { repositoryConfigs } from '@/db/schema';
import { eq, and } from 'drizzle-orm';

// Handle push events - sync config if .agentpane files changed
export async function handlePushEvent(payload: PushPayload): Promise<void> {
  const { repository, ref, commits, installation } = payload;

  // Only process pushes to default branch
  if (ref !== `refs/heads/${repository.default_branch}`) {
    return;
  }

  // Check if any .agentpane files were modified
  const configChanged = commits?.some((commit) =>
    [...(commit.added ?? []), ...(commit.modified ?? []), ...(commit.removed ?? [])]
      .some((path) => path.startsWith('.agentpane/'))
  );

  if (configChanged && installation) {
    console.log(`[Webhook] Config changed in ${repository.full_name}, syncing...`);
    await syncConfig(
      installation.id,
      repository.owner.login,
      repository.name
    );
  }
}

// Handle pull request events
export async function handlePREvent(payload: PRPayload): Promise<void> {
  const { action, pull_request, repository } = payload;

  switch (action) {
    case 'opened':
      console.log(`[Webhook] PR #${pull_request.number} opened in ${repository.full_name}`);
      // Could trigger code review agent
      break;

    case 'closed':
      if (pull_request.merged) {
        console.log(`[Webhook] PR #${pull_request.number} merged in ${repository.full_name}`);
        // Could update task status
      }
      break;

    case 'synchronize':
      console.log(`[Webhook] PR #${pull_request.number} updated in ${repository.full_name}`);
      break;
  }
}

// Handle installation events
export async function handleInstallationEvent(payload: InstallationPayload): Promise<void> {
  const { action, installation, repositories } = payload;

  switch (action) {
    case 'created':
      console.log(`[Webhook] App installed for ${installation.account.login}`);
      await saveInstallation(installation);
      break;

    case 'deleted':
      console.log(`[Webhook] App uninstalled from ${installation.account.login}`);
      await removeInstallation(String(installation.id));
      break;

    case 'suspend':
      console.log(`[Webhook] Installation suspended for ${installation.account.login}`);
      await db.update(githubInstallations)
        .set({ status: 'suspended', suspendedAt: new Date() })
        .where(eq(githubInstallations.id, String(installation.id)));
      break;

    case 'unsuspend':
      console.log(`[Webhook] Installation unsuspended for ${installation.account.login}`);
      await db.update(githubInstallations)
        .set({ status: 'active', suspendedAt: null })
        .where(eq(githubInstallations.id, String(installation.id)));
      break;

    case 'new_permissions_accepted':
      console.log(`[Webhook] New permissions accepted for ${installation.account.login}`);
      await saveInstallation(installation);
      break;
  }
}

// Handle issues events
export async function handleIssuesEvent(payload: IssuesPayload): Promise<void> {
  const { action, issue, repository } = payload;

  switch (action) {
    case 'opened':
      console.log(`[Webhook] Issue #${issue.number} opened in ${repository.full_name}`);
      // Could create task from issue
      break;

    case 'closed':
      console.log(`[Webhook] Issue #${issue.number} closed in ${repository.full_name}`);
      break;

    case 'labeled':
      // Could trigger agent if specific label added
      break;
  }
}
```

---

## Pull Request Management

### PR Service

```typescript
// lib/github/pull-requests.ts
import { createInstallationOctokit } from './client';
import type { Result } from '@/lib/utils/result';
import { ok, err } from '@/lib/utils/result';
import { GitHubErrors } from '@/lib/errors/github-errors';

export interface CreatePRParams {
  installationId: number;
  owner: string;
  repo: string;
  title: string;
  body: string;
  head: string;           // Branch with changes
  base: string;           // Target branch (usually main)
  draft?: boolean;
}

export interface PRInfo {
  number: number;
  url: string;
  state: string;
  mergeable: boolean | null;
  merged: boolean;
}

// Create pull request
export async function createPullRequest(
  params: CreatePRParams
): Promise<Result<PRInfo, GitHubError>> {
  const { installationId, owner, repo, title, body, head, base, draft } = params;

  try {
    const octokit = createInstallationOctokit(installationId);

    const { data } = await octokit.rest.pulls.create({
      owner,
      repo,
      title,
      body,
      head,
      base,
      draft: draft ?? false,
    });

    return ok({
      number: data.number,
      url: data.html_url,
      state: data.state,
      mergeable: data.mergeable,
      merged: data.merged,
    });
  } catch (error: any) {
    if (error.status === 422) {
      // PR already exists or validation error
      return err(GitHubErrors.PR_CREATION_FAILED(error.message));
    }
    return err(GitHubErrors.PR_CREATION_FAILED(String(error)));
  }
}

// Merge pull request
export async function mergePullRequest(
  installationId: number,
  owner: string,
  repo: string,
  pullNumber: number,
  commitTitle?: string,
  mergeMethod: 'merge' | 'squash' | 'rebase' = 'squash'
): Promise<Result<void, GitHubError>> {
  try {
    const octokit = createInstallationOctokit(installationId);

    await octokit.rest.pulls.merge({
      owner,
      repo,
      pull_number: pullNumber,
      commit_title: commitTitle,
      merge_method: mergeMethod,
    });

    return ok(undefined);
  } catch (error: any) {
    return err(GitHubErrors.PR_CREATION_FAILED(`Merge failed: ${error.message}`));
  }
}

// Get PR status
export async function getPullRequestStatus(
  installationId: number,
  owner: string,
  repo: string,
  pullNumber: number
): Promise<Result<PRInfo, GitHubError>> {
  try {
    const octokit = createInstallationOctokit(installationId);

    const { data } = await octokit.rest.pulls.get({
      owner,
      repo,
      pull_number: pullNumber,
    });

    return ok({
      number: data.number,
      url: data.html_url,
      state: data.state,
      mergeable: data.mergeable,
      merged: data.merged,
    });
  } catch (error: any) {
    if (error.status === 404) {
      return err(GitHubErrors.REPO_NOT_FOUND(owner, repo));
    }
    return err(GitHubErrors.AUTH_FAILED(String(error)));
  }
}

// Add comment to PR
export async function addPRComment(
  installationId: number,
  owner: string,
  repo: string,
  pullNumber: number,
  body: string
): Promise<Result<void, GitHubError>> {
  try {
    const octokit = createInstallationOctokit(installationId);

    await octokit.rest.issues.createComment({
      owner,
      repo,
      issue_number: pullNumber,
      body,
    });

    return ok(undefined);
  } catch (error: any) {
    return err(GitHubErrors.PR_CREATION_FAILED(`Comment failed: ${error.message}`));
  }
}
```

---

## Database Tables

### GitHub Installation Table

Defined in `/specs/database/schema.md`:

```typescript
export const githubInstallations = pgTable('github_installations', {
  id: text('id').primaryKey(),
  accountId: text('account_id').notNull(),
  accountLogin: text('account_login').notNull(),
  accountType: text('account_type').notNull(),
  accountAvatarUrl: text('account_avatar_url'),
  status: installationStatusEnum('status').notNull().default('active'),
  permissions: jsonb('permissions').$type<Record<string, string>>().default({}),
  repositorySelection: text('repository_selection'),
  installedAt: timestamp('installed_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
  suspendedAt: timestamp('suspended_at'),
});
```

### Repository Config Table

```typescript
export const repositoryConfigs = pgTable('repository_configs', {
  id: text('id').primaryKey().$defaultFn(() => createId()),
  installationId: text('installation_id').notNull().references(() => githubInstallations.id, { onDelete: 'cascade' }),
  owner: text('owner').notNull(),
  repo: text('repo').notNull(),
  fullName: text('full_name').notNull(),
  configPath: text('config_path').notNull().default('.agentpane'),
  configSha: text('config_sha'),
  config: jsonb('config').$type<Record<string, unknown>>().default({}),
  lastSyncedAt: timestamp('last_synced_at'),
  syncError: text('sync_error'),
  defaultBranch: text('default_branch').default('main'),
  isPrivate: boolean('is_private').default(false),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});
```

---

## API Endpoints Summary

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/github/authorize` | GET | Start OAuth flow |
| `/api/github/callback` | GET | OAuth callback handler |
| `/api/github/installations` | GET | List all installations |
| `/api/github/installations/:id/repos` | GET | List repos for installation |
| `/api/github/repos/:owner/:repo/config` | GET | Get repo config |
| `/api/github/repos/:owner/:repo/sync` | POST | Force config sync |
| `/api/webhooks/github` | POST | Webhook handler |

---

## Rate Limiting

### GitHub API Rate Limits

| Resource | Limit | Reset |
|----------|-------|-------|
| REST API (Installation) | 5,000/hour | Hourly |
| REST API (User) | 5,000/hour | Hourly |
| Search API | 30/minute | Per minute |
| GraphQL API | 5,000 points/hour | Hourly |

### Rate Limit Handling

```typescript
// lib/github/rate-limit.ts
import { Octokit } from 'octokit';

export async function checkRateLimit(octokit: Octokit): Promise<RateLimitInfo> {
  const { data } = await octokit.rest.rateLimit.get();

  return {
    limit: data.rate.limit,
    remaining: data.rate.remaining,
    reset: new Date(data.rate.reset * 1000),
  };
}

export function handleRateLimitError(error: any): GitHubError {
  if (error.status === 403 && error.headers?.['x-ratelimit-remaining'] === '0') {
    const resetAt = parseInt(error.headers['x-ratelimit-reset'], 10);
    return GitHubErrors.RATE_LIMITED(resetAt);
  }
  throw error;
}
```

---

## Cross-References

| Spec | Relationship |
|------|--------------|
| [Database Schema](../database/schema.md) | GitHub tables definition |
| [Error Catalog](../errors/error-catalog.md) | GitHub error codes |
| [User Stories](../user-stories.md) | Config sync requirements |
| [Git Worktrees](./git-worktrees.md) | Branch/PR integration |
| [Test Cases](../testing/test-cases.md) | GitHub integration tests |
